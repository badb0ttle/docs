[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:$}=Object,{fromEntries:st}=Object,nt="ENTRIES",D="KEYS",W="VALUES",_="";class S{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(typeof t!="string")return n;const o=t.length+1,r=o+s,i=new Uint8Array(r*o).fill(s+1);for(let c=0;c<o;++c)i[c]=c;for(let c=1;c<r;++c)i[c*o]=c;return q(e,t,s,n,i,1,o,""),n},q=(e,t,s,n,o,r,i,c)=>{const l=r*i;t:for(const u of e.keys())if(u===_){const h=o[l-1];h<=s&&n.set(c,[e.get(u),h])}else{let h=r;for(let f=0;f<u.length;++f,++h){const m=u[f],g=i*h,y=g-i;let d=o[g];const a=Math.max(0,h-s-1),w=Math.min(i-1,h+s);for(let p=a;p<w;++p){const O=m!==t[p],C=o[y+p]+ +O,k=o[y+p+1]+1,x=o[g+p]+1,v=o[g+p+1]=Math.min(C,k,x);v<d&&(d=v)}if(d>s)continue t}q(e.get(u),t,s,n,o,h,i,c+u)}};class z{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=I(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const i of o.keys())if(i!==_&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),o.get(i)),new z(c,t)}}return new z(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,rt(this._tree,t)}entries(){return new S(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=F(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return F(this._tree,t)?.has(_)??!1}keys(){return new S(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new S(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new z;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return z.from(Object.entries(t))}}const I=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),I(e.get(n),t.slice(n.length),s);return s.push([e,t]),I(void 0,"",s)},F=(e,t)=>{if(t.length===0||!e)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return F(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const i=Math.min(s-n,r.length);let c=1;for(;c<i&&t[n+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(n,n+c),u),e.delete(r),e=u}n+=c;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},rt=(e,t)=>{const[s,n]=I(e,t);if(s!==void 0){if(s.delete(_),s.size===0)A(n);else if(s.size===1){const[o,r]=s.entries().next().value;R(n,o,r)}}},A=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)A(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&R(e.slice(0,-1),n,o)}},R=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},ct=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ut="and_not",ht=(e,t)=>{e.includes(t)||e.push(t)},B=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,M=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,H={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),B(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:i,match:c}=t.get(n);B(o.terms,i),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,c)})}return s},[ut]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(s-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*n/o)))},at=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),J=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){J(e,s,t,n);return}const o=e._index.fetch(n,lt),r=o.get(t),i=r?.get(s);!r||typeof i>"u"?J(e,s,t,n):i<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,i-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(ct),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},Y={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},K={minDirtFactor:.1,minDirtCount:20},yt={..._t,...K},U=Symbol("*"),wt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const i=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},Q=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase();if(!(s in H))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(H[s])},T=(e,t,s,n,o,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const h of Object.keys(i)){const f=i[h],m=e._fieldIds[h],g=r.get(m);if(g==null)continue;let y=g.size;const d=e._avgFieldLength[m];for(const a of g.keys()){if(!e._documentIds.has(a)){ft(e,m,a,s),y-=1;continue}const w=c?c(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!w)continue;const p=g.get(a),O=e._fieldLength.get(a)[m],C=dt(p,y,e._documentCount,O,d,l),k=n*o*f*w*C,x=u.get(a);if(x){x.score+=k,ht(x.terms,t);const v=G(x.match,s);v?v.push(h):x.match[s]=[h]}else u.set(a,{score:k,terms:[t],match:{[s]:[h]}})}}return u},xt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((d,a)=>({...d,[a]:G(n.boost,a)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=n,{fuzzy:u,prefix:h}={...Y.weights,...i},f=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,f,o,r,l);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,a=d<1?Math.min(c,Math.round(t.term.length*d)):d;a&&(y=e._index.fuzzyGet(t.term,a))}if(g)for(const[d,a]of g){const w=d.length-t.term.length;if(!w)continue;y?.delete(d);const p=h*d.length/(d.length+.3*w);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}if(y)for(const d of y.keys()){const[a,w]=y.get(d);if(!w)continue;const p=u*d.length/(d.length+w);T(e,t.term,d,p,t.termBoost,a,o,r,l,m)}return m},X=(e,t,s={})=>{if(t===U)return wt(e,s);if(typeof t!="string"){const h={...s,...t,queries:void 0},f=t.queries.map(m=>X(e,m,h));return Q(f,h.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,i={tokenize:n,processTerm:o,...r,...s},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(h=>l(h)).filter(h=>!!h).map(at(i)).map(h=>xt(e,h,i));return Q(u,i.combineWith)},Z=(e,t,s={})=>{const{searchOptions:n}=e._options,o={...n,...s},r=X(e,t,s),i=[];for(const[c,{score:l,terms:u,match:h}]of r){const f=u.length||1,m={id:e._documentIds.get(c),score:l*f,terms:Object.keys(h),queryTerms:u,match:h};Object.assign(m,e._storedFields.get(c)),(o.filter==null||o.filter(m))&&i.push(m)}return t===U&&o.boostDocument==null||i.sort(P),i},zt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:i}of Z(e,t,s)){const c=i.join(" "),l=n.get(c);l!=null?(l.score+=r,l.count+=1):n.set(c,{score:r,terms:i,count:1})}const o=[];for(const[r,{score:i,terms:c,count:l}]of n)o.push({suggestion:r,terms:c,score:i/l});return o.sort(P),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...Y,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new z,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=K,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,i]of n)o[r]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const vt=e=>new bt(e),kt=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=vt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=s,c._avgFieldLength=n,c._dirtCount=o??0,c._index=new z,c},It=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,i=kt(e,t);i._documentIds=M(n),i._fieldLength=M(o),i._storedFields=M(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of s){const u=new Map;for(const h of Object.keys(l))u.set(parseInt(h,10),M(l[h]));i._index.set(c,u)}return i},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,i=0;const c=(u,h=!1)=>{let f;i===0?f=u.length>20?`… ${u.slice(-20)}`:u:h?f=u.length+i>100?`${u.slice(0,100-i)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&o.push(f),i+=f.length,h||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let l=s.indexOf(n,r);if(l===-1)return null;for(;l>=0;){const u=l+n.length;if(c(e.slice(r,l)),r=u,i>100)break;l=s.indexOf(n,r)}return i<100&&c(e.slice(r),!0),o},Mt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ot=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),tt=(e,t,s={})=>{const n={};return Z(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:i,score:c}=o,l=r.includes("@"),u=r.includes("#"),[h,f]=r.split(/[#@]/),m=Number(h),g=i.sort((d,a)=>d.length-a.length).filter((d,a)=>i.slice(a+1).every(w=>!w.includes(d))),{contents:y}=n[m]??={title:"",contents:[]};if(l)y.push([{type:"customField",id:m,index:f,display:g.map(d=>o.c.map(a=>V(a,d))).flat().filter(d=>d!==null)},c]);else{const d=g.map(a=>V(o.h,a)).filter(a=>a!==null);if(d.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:f},display:d},c]),"t"in o&&o.t)for(const a of o.t){const w=g.map(p=>V(a,p)).filter(p=>p!==null);w.length&&y.push([{type:"text",id:m,...u&&{anchor:f},display:w},c])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Mt(o,r):Ot(o,r)).map(([o,{title:r,contents:i}])=>{if(!r){const c=it(t,o);c&&(r=c.h)}return{title:r,contents:i.map(([c])=>c)}})},et=(e,t,s={})=>{const n=zt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},Ct=st($(JSON.parse("{\"/\":{\"documentCount\":124,\"nextId\":124,\"documentIds\":{\"0\":\"0\",\"1\":\"0@0\",\"2\":\"1\",\"3\":\"1#组合数\",\"4\":\"1#方法一-数据规模较小时使用动态规划-dp\",\"5\":\"1#方法二-空间足够时使用快速幂\",\"6\":\"1#代码解释\",\"7\":\"1@0\",\"8\":\"2\",\"9\":\"2#线性、区间、树形-dp\",\"10\":\"2#_1-线性-dp\",\"11\":\"2#_2-区间-dp\",\"12\":\"2#_3-树形-dp\",\"13\":\"2@0\",\"14\":\"3\",\"15\":\"3#数组离散化\",\"16\":\"3#离散化步骤\",\"17\":\"3#代码实现\",\"18\":\"3#树状数组\",\"19\":\"3#区间查询\",\"20\":\"3#单点修改\",\"21\":\"3#区间修改\",\"22\":\"3@0\",\"23\":\"4\",\"24\":\"4#贪心策略\",\"25\":\"4@0\",\"26\":\"5\",\"27\":\"5#_1-01-背包\",\"28\":\"5#第一形态\",\"29\":\"5#第二形态\",\"30\":\"5#第三形态\",\"31\":\"5#_2-无穷背包\",\"32\":\"5#第一形态-1\",\"33\":\"5#第二形态-1\",\"34\":\"5#第三形态-1\",\"35\":\"5#_3-多重背包\",\"36\":\"5#第一形态-2\",\"37\":\"5#第二形态-2\",\"38\":\"5@0\",\"39\":\"6\",\"40\":\"6#简单情形\",\"41\":\"6#困难情形-单调栈二分动态规划核心思想\",\"42\":\"6#_1-单调栈\",\"43\":\"6#_2-二分查找\",\"44\":\"6#_3-动态规划\",\"45\":\"6#狄尔沃斯定理\",\"46\":\"6@0\",\"47\":\"7\",\"48\":\"7@0\",\"49\":\"8\",\"50\":\"8#搜素专题\",\"51\":\"8#_1-dfs\",\"52\":\"8#_2-bfs\",\"53\":\"8@0\",\"54\":\"9\",\"55\":\"9#后缀\",\"56\":\"9#前缀\",\"57\":\"9#查找相关方法\",\"58\":\"9#截取与拼接方法\",\"59\":\"9#替换方法\",\"60\":\"9#删除与插入方法\",\"61\":\"9#比较运算符\",\"62\":\"9@0\",\"63\":\"10\",\"64\":\"10@0\",\"65\":\"11\",\"66\":\"11@0\",\"67\":\"12\",\"68\":\"12@0\",\"69\":\"13\",\"70\":\"13@0\",\"71\":\"14\",\"72\":\"14#基础知识\",\"73\":\"14#vuepress扩展\",\"74\":\"14#markdown-介绍\",\"75\":\"14#markdown-配置\",\"76\":\"14#markdown-扩展\",\"77\":\"14#vuepress-扩展\",\"78\":\"14#主题扩展\",\"79\":\"14#选项卡\",\"80\":\"14#脚注\",\"81\":\"14#导入文件\",\"82\":\"14#tex-语法\",\"83\":\"14#任务列表\",\"84\":\"14#图片增强\",\"85\":\"14#上下角标\",\"86\":\"14#组件\",\"87\":\"14@0\",\"88\":\"15\",\"89\":\"15#页面标题\",\"90\":\"15#页面信息\",\"91\":\"15#页面内容\",\"92\":\"15#组件\",\"93\":\"15@0\",\"94\":\"16\",\"95\":\"16@0\",\"96\":\"17\",\"97\":\"17@0\",\"98\":\"18\",\"99\":\"18@0\",\"100\":\"19\",\"101\":\"19#git基础\",\"102\":\"19#git指令-基础命令\",\"103\":\"19#git指令-远程\",\"104\":\"19@0\",\"105\":\"20\",\"106\":\"21\",\"107\":\"21@0\",\"108\":\"22\",\"109\":\"22@0\",\"110\":\"23\",\"111\":\"23@0\",\"112\":\"24\",\"113\":\"24@0\",\"114\":\"25\",\"115\":\"25@0\",\"116\":\"26\",\"117\":\"26@0\",\"118\":\"27\",\"119\":\"27@0\",\"120\":\"28\",\"121\":\"28@0\",\"122\":\"29\",\"123\":\"29@0\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[null,null,1],\"2\":[4],\"3\":[1,3],\"4\":[4,29],\"5\":[2,50],\"6\":[1,24],\"7\":[null,null,4],\"8\":[8],\"9\":[4,5],\"10\":[3,36],\"11\":[3,46],\"12\":[3,20],\"13\":[null,null,8],\"14\":[6,3],\"15\":[1],\"16\":[1,7],\"17\":[1,31],\"18\":[1,20],\"19\":[1,16],\"20\":[1,14],\"21\":[1,47],\"22\":[null,null,6],\"23\":[3,3],\"24\":[1,34],\"25\":[null,null,3],\"26\":[4,3],\"27\":[3,2],\"28\":[1,24],\"29\":[1,36],\"30\":[1,41],\"31\":[2,2],\"32\":[1,25],\"33\":[1,7],\"34\":[1,32],\"35\":[2,5],\"36\":[1,21],\"37\":[1,49],\"38\":[null,null,4],\"39\":[5,3],\"40\":[1,35],\"41\":[2],\"42\":[2,8],\"43\":[2,19],\"44\":[2,51],\"45\":[1,8],\"46\":[null,null,5],\"47\":[1],\"48\":[null,null,1],\"49\":[3],\"50\":[1,3],\"51\":[2,9],\"52\":[2,8],\"53\":[null,null,3],\"54\":[3,3],\"55\":[1,17],\"56\":[1,25],\"57\":[1,17],\"58\":[1,17],\"59\":[1,13],\"60\":[1,11],\"61\":[1,7],\"62\":[null,null,3],\"63\":[1],\"64\":[null,null,1],\"65\":[1],\"66\":[null,null,1],\"67\":[1],\"68\":[null,null,1],\"69\":[1,20],\"70\":[null,null,1],\"71\":[1],\"72\":[1,16],\"73\":[1,10],\"74\":[2,8],\"75\":[2,12],\"76\":[2,11],\"77\":[2,10],\"78\":[1,8],\"79\":[1,1],\"80\":[1,2],\"81\":[1,1],\"82\":[2,10],\"83\":[1,5],\"84\":[1,2],\"85\":[1,3],\"86\":[1],\"87\":[null,null,1],\"88\":[1,1],\"89\":[1,19],\"90\":[1,48],\"91\":[1,12],\"92\":[1,13],\"93\":[null,null,1],\"94\":[1],\"95\":[null,null,1],\"96\":[1],\"97\":[null,null,1],\"98\":[1],\"99\":[null,null,1],\"100\":[1],\"101\":[1,7],\"102\":[3,51],\"103\":[3,67],\"104\":[null,null,1],\"105\":[1,3],\"106\":[1],\"107\":[null,null,1],\"108\":[2],\"109\":[null,null,2],\"110\":[2],\"111\":[null,null,2],\"112\":[1],\"113\":[null,null,1],\"114\":[2],\"115\":[null,null,2],\"116\":[2],\"117\":[null,null,2],\"118\":[1],\"119\":[null,null,1],\"120\":[1],\"121\":[null,null,1],\"122\":[1],\"123\":[null,null,1]},\"averageFieldLength\":[1.7266280398221308,17.136112737150672,1.7253732107808142],\"storedFields\":{\"0\":{\"h\":\"Home\"},\"1\":{\"c\":[\"Home\"]},\"2\":{\"h\":\"Combination Numbers(组合数)\"},\"3\":{\"h\":\"组合数\",\"t\":[\"原文oi wiki:组合数\"]},\"4\":{\"h\":\"方法一：数据规模较小时使用动态规划（DP）\",\"t\":[\"当数据规模较小时，可以使用动态规划的方式计算组合数。其核心思路基于组合数的递推公式\",\"Cij​=Ci−1j​+Ci−1j−1​\",\"// 初始化边界条件：C[i][0] 都为 1 for(int i = 0; i <= n; ++i) C[i][0] = 1; // 动态规划计算组合数 for(int i = 1; i <= n; ++i) { // 注意 j 的范围，避免越界 for(int j = 1; j < m && j <= i; ++j) { // 根据递推公式计算组合数，并对结果取模 C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } }\"]},\"5\":{\"h\":\"方法二：空间足够时使用快速幂\",\"t\":[\"当空间足够时，可以使用快速幂的方法来计算组合数。此方法先预处理阶乘和逆元，再根据组合数公式计算组合数。\",\"Cnm​=m!(n−m)!n!​\",\"// 快速幂函数，计算 a 的 b 次方对 mod 取模的结果 int qp(int a, int b, int mod) { int res = 1; while(b) { if(b & 1) res = (res * a) % mod; b >>= 1; a = (a * a) % mod; } return res; } // 预处理阶乘和逆元 void pre() { // 0 的阶乘和 0 的阶乘的逆元都为 1 fac[0] = inv[0] = 1; for(int i = 1; i < mx; ++i) { // 计算阶乘 fac[i] = fac[i - 1] * i % mod; // 计算阶乘的逆元 inv[i] = qp(fac[i], mod - 2, mod); } } // 计算组合数 C(n, m) int C(int n, int m) { // 处理特殊情况 if(n == 0 || m == 0 || n < m) return 0; // 根据组合数公式计算结果 else return (fac[n] * inv[m] % mod * inv[n - m]) % mod; }\"]},\"6\":{\"h\":\"代码解释\",\"t\":[\"qp 函数：用于计算快速幂，通过二进制拆分的方式，将时间复杂度从 (O(b)) 优化到 (O(logb))。\",\"pre 函数：预处理阶乘数组 fac 和逆元数组 inv，方便后续计算组合数时直接使用。\",\"C 函数：根据预处理好的阶乘和逆元，计算组合数 (C(n, m))。其中 fac 数组存储阶乘，inv 数组存储逆元。\"]},\"7\":{\"c\":[\"Combination Numbers(组合数)\"]},\"8\":{\"h\":\"DP:Linear, Interval, Tree (线性、区间、树形dp)\"},\"9\":{\"h\":\"线性、区间、树形 DP\",\"t\":[\"原文oi wiki:树形 DP区间 DP\"]},\"10\":{\"h\":\"1. 线性 DP\",\"t\":[\"每个状态只依赖于前一个或前几个状态，且状态转移是线性的（即没有复杂的依赖关系）。通常用于解决序列或数组上的问题。\",\"dp[i][j]: 到第 i 种为止，总数为 j 的总方案数。\",\"例题: P1077\",\"dp[0][0] = 1; // 初始化 for(int i = 1; i <= n; ++i) { // 到第 i 种花为止 for(int j = 0; j <= m; ++j) { // 一共放了 j 盆花 for(int k = 0; k <= a[i] && k <= j; ++k) { // 第 i 种花放了 k 盆 dp[i][j] = (dp[i-1][j - k] + dp[i][j]) % mod; } } }\"]},\"11\":{\"h\":\"2. 区间 DP\",\"t\":[\"区间 DP 是指状态转移方程中，每个状态表示一个区间 [i, j] 上的某种性质，且状态转移依赖于更小的子区间。通常用于解决区间划分、合并、分割等问题。\",\"步骤:\",\"先求小区间的 DP。 转移到大区间。 初始化。 例题: P5569\",\"const int mx = 301, inf = 4e18; int a[mx], dp[mx][mx], n, pre[mx]; void work() { cin >> n; for(int i = 1; i <= n; ++i) cin >> a[i]; for(int i = 1; i <= n; ++i) pre[i] = a[i] + pre[i - 1]; for(int len = 2; len <= n; ++len) { for(int i = 1, j = i + len - 1; j <= n; ++i, ++j) { dp[i][j] = inf; for(int k = i; k < j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + pre[j] - pre[i - 1]); } } } }\"]},\"12\":{\"h\":\"3. 树形 DP\",\"t\":[\"通常利用树的递归性质，从子树的解推导出父节点的解，核心思想是将原问题分解为若干子问题，通过求解子问题来得到原问题的解。在树形 DP 中，我们一般会进行深度优先搜索（DFS）来遍历树的节点，从而完成状态的转移。\",\"步骤:\",\"构造一种方案，并设定一个归属。 确定状态、表示。 状态转移。 遍历顺序。 例题: P1122\"]},\"13\":{\"c\":[\"DP:Linear, Interval, Tree (线性、区间、树形dp)\"]},\"14\":{\"h\":\"Discretization & Fenwick Tree Special(离散化和树状数组)\",\"t\":[\"原文oi wiki:树状数组离散化\"]},\"15\":{\"h\":\"数组离散化\"},\"16\":{\"h\":\"离散化步骤\",\"t\":[\"创建原数组的副本，同时记录每个元素出现的位置。\",\"将副本按值从小到大排序，当值相同时，按出现顺序从小到大排序。\",\"将离散化后的数字放回原数组。\"]},\"17\":{\"h\":\"代码实现\",\"t\":[\"struct Data { int idx, val; bool operator<(const Data& o) const { if (val == o.val) return idx < o.idx; // 当值相同时，先出现的元素离散化后的值更小 return val < o.val; } } tmp[MAXN]; // 也可以使用 std::pair for (int i = 1; i <= n; ++i) tmp[i] = Data{i, arr[i]}; std::sort(tmp + 1, tmp + n + 1); for (int i = 1; i <= n; ++i) arr[tmp[i].idx] = i;\"]},\"18\":{\"h\":\"树状数组\",\"t\":[\"树状数组是一种支持 单点修改 和 区间查询 的、代码量小的数据结构。 即，维护区间和: {1.单点修改 O(1), 2.区间修改 O(logN), 3.查询 O(logN)} 但注意: 不能用 0 当下标。\"]},\"19\":{\"h\":\"区间查询\",\"t\":[\"int getsum(int x) { // a[1]..a[x]的和 int ans = 0; while (x > 0) { ans = ans + c[x]; x = x - lowbit(x); } return ans; }\"]},\"20\":{\"h\":\"单点修改\",\"t\":[\"void add(int x, int k) { while (x <= n) { // 不能越界 c[x] = c[x] + k; x = x + lowbit(x); } }\"]},\"21\":{\"h\":\"区间修改\",\"t\":[\"void update(int k, lL x) { for(int i = k; i <= n; i += lowbit(i)) { td[i] += x, ti_td[i] += x * k; } } lL getsum(int k) { lL sum = 0; for(int i = k; i > 0; i -= lowbit(i)) { sum += (k + 1) * td[i] - ti_td[i]; } return sum; }\",\"解释: add 是对指定区间进行维护的操作，即从 k 迭代到 n 的不同管辖区间修改操作，而 td 和 ti_td 分别都是不同系数的差分数组。因此，我们实际上是用两个树状数组来维护 d_i 和 d_i * i 这个操作。getsum 里的区间查询则是用推导公式：\",\"i=1∑r​di​×(r+1)−i=1∑r​di​×i\",\"实现的（这里的 k 实际上等同于 r，都是 1 到 k 的区间和）。\"]},\"22\":{\"c\":[\"Discretization & Fenwick Tree Special(离散化和树状数组)\"]},\"23\":{\"h\":\"Greedy (贪心)\",\"t\":[\"原文oi wiki:贪心\"]},\"24\":{\"h\":\"贪心策略\",\"t\":[\"序列定义：\",\"序列 a:a1​,a2​,a3​,⋯,an​\",\"序列 b:b1​,b2​,b3​,⋯,bn​\",\"问题：求 ∑ai​bj​（(i, j) 不重复）的最大值\",\"表达式：\",\"max=a(1)​b(1)​+a(2)​b(2)​+⋯+a(n)​b(n)​ （其中 a(i)​ 是序列 (a) 中第 (i) 大的元素，b(i)​ 是序列 (b) 中第 (i) 大的元素）\"]},\"25\":{\"c\":[\"Greedy (贪心)\"]},\"26\":{\"h\":\"Knapsack DP(背包dp)\",\"t\":[\"原文oi wiki:背包dp\"]},\"27\":{\"h\":\"1. 01 背包\",\"t\":[\"每个物品只能获取一次。\"]},\"28\":{\"h\":\"第一形态\",\"t\":[\"dp[i][j]: 选前 i 个元素，空间为 j 的最大价值。\",\"for(int i = 1; i <= m; ++i) { for(int j = 1; j <= t; ++j) { if(j >= T[i]) dp[i][j] = max(dp[i-1][j - T[i]] + M[i], dp[i-1][j]); else dp[i][j] = dp[i-1][j]; } }\"]},\"29\":{\"h\":\"第二形态\",\"t\":[\"因为我们的 01 背包不考虑方案整体，只考虑前后关系，因此我们可以只维护当前和前一项这两种状态，采用 0 和 1 这两种状态存储。\",\"dp[y][j]: 当前状态下空间为 j 的最大价值。\",\"for(int i = 1; i <= m; ++i) { int y = i & 1; for(int j = 1; j <= t; ++j) { if(j >= T[i]) dp[y][j] = max(dp[y^1][j - T[i]] + M[i], dp[y^1][j]); else dp[y][j] = dp[y^1][j]; } } cout << dp[m & 1][t] << \\\"\\\\n\\\";\"]},\"30\":{\"h\":\"第三形态\",\"t\":[\"压缩成一维，将之前状态存储在左边，当前的状态存储在数组末尾。从左往右遍历：\",\"for(int i = 1; i <= m; ++i) { for(int j = t; j >= T[i]; --j) { if(j >= T[i]) dp[j] = max(dp[j - T[i]] + W[i], dp[j]); else dp[j] = dp[j]; } }\",\"解释: 如果从左往右遍历，dp[j - w[i]] 可能会被更新多次（因为 j - w[i] 比 j 小，已经在当前轮次被更新过）。 这样会导致一个物品被多次选择，违反了 01 背包中“每个物品只能选一次”的规则。 从右往左遍历可以保证 dp[j - w[i]] 是上一轮的状态（即未选择当前物品时的状态），从而确保每个物品只被选择一次。\"]},\"31\":{\"h\":\"2. 无穷背包\",\"t\":[\"即每个物品有无限次获取的机会。\"]},\"32\":{\"h\":\"第一形态\",\"t\":[\"dp[i][j]: 选若干个 i 个元素，空间为 j 的最大价值。\",\"for(int i = 1; i <= n; ++i) { for(int j = 0; j <= m; ++j) { if(j >= v[i]) dp[i][j] = max(dp[i-1][j], dp[i][j - v[i]] + w[i]); else dp[i][j] = dp[i-1][j]; } }\"]},\"33\":{\"h\":\"第二形态\",\"t\":[\"同上，dp[y][j]: 当前状态下空间为 j 的最大价值。\"]},\"34\":{\"h\":\"第三形态\",\"t\":[\"从左往右遍历时，dp[j - w[i]] 可能会被更新多次（因为 j - w[i] 比 j 小，已经在当前轮次被更新过）。 这样正好符合完全背包中“每个物品可以选择多次”的规则。 每次更新 dp[j] 时，dp[j - w[i]] 已经包含了当前物品可能被选择多次的情况。 dp[j]: 到目前为止，花费空间为 j 的最大价值。\",\"for(int i = 1; i <= n; ++i) { for(int j = v[i]; j <= m; ++j) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } }\"]},\"35\":{\"h\":\"3. 多重背包\",\"t\":[\"即每个物品都有 s[i] 次获取的机会。\"]},\"36\":{\"h\":\"第一形态\",\"t\":[\"for(int i = 1; i <= n; ++i) { cin >> s >> w >> v; while(s--) { for(int j = m; j >= v; --j) dp[j] = max(dp[j], dp[j - v] + w); } }\"]},\"37\":{\"h\":\"第二形态\",\"t\":[\"二进制优化的核心思想是：\",\"将每种物品的数量 s 拆分成若干个 2 的幂次方的组合（如 1, 2, 4, 8, ...），再加上剩余的部分。 这样，每种物品的数量 s 可以被拆分成 log(s) 个物品，而不是 s 个物品。 通过这种方式，多重背包问题被转化为 01 背包问题，且物品数量大大减少。\",\"for(int i = 1; i <= n; ++i) { cin >> s >> w >> v; vector<int> vec; int x = 1; while(s >= x) { vec.push_back(x); s -= x; x <<= 1; } if(s) vec.push_back(s); for(int k : vec) { for(int j = m; j >= k * v; --j) dp[j] = max(dp[j], dp[j - k * v] + k * w); } }\"]},\"38\":{\"c\":[\"Knapsack DP(背包dp)\"]},\"39\":{\"h\":\"Longest Increasing Subsequence(最长上升子序列）\",\"t\":[\"原文oi wiki:LIS\"]},\"40\":{\"h\":\"简单情形\",\"t\":[\"在最长上升子序列问题中，我们引入两个关键变量 i 和 j。这里，i 表示以其作为结尾的最长上升子序列的长度，而 j 则作为连接点，在构建最长上升子序列的过程中起着重要作用。\",\"需要特别注意的是，dp[mx] 并不一定就是最终答案。在得出所有以不同元素结尾的最长上升子序列长度后，我们需要遍历整个结果数组，才能找出真正的最长上升子序列长度。\",\" for(int i=1;i<=n;++i) { dp[i]=1; for(int j=1;j<i;++j) { if(a[j]<=a[i]) dp[i]=max(dp[i],dp[j]+1); } } int ans=0; for(int i=1;i<=n;++i)ans=max(ans,dp[i]);\"]},\"41\":{\"h\":\"困难情形：单调栈二分动态规划核心思想\"},\"42\":{\"h\":\"1. 单调栈\",\"t\":[\"我们维护一个单调递增的栈 stk，这个栈用于存储当前有可能构成最长上升子序列的元素。栈的关键特性在于其中的元素始终保持单调递增，借助这一特性，我们能够快速定位当前元素在栈中应该插入的位置，从而高效地构建潜在的最长上升子序列。\"]},\"43\":{\"h\":\"2. 二分查找\",\"t\":[\"对于序列中的每个元素 a[i]，我们运用二分查找算法在单调栈 stk 中找出第一个大于等于 a[i] 的位置。若该位置位于栈内，我们用 a[i] 替换此位置的元素；若不存在这样的位置，即 a[i] 大于栈内所有元素，我们将 a[i] 压入栈中。通过这种方式，不断优化栈内元素，逐步逼近最长上升子序列。\"]},\"44\":{\"h\":\"3. 动态规划\",\"t\":[\"通过巧妙维护单调栈，我们能够动态地更新最长上升子序列的长度。在整个过程中，我们要牢记三个核心要点：\",\"二分查找位置：准确运用二分查找确定元素在栈中的合适位置。\",\"更长则更新：当遇到能使上升子序列更长的元素时，要及时更新相关信息。这里强调的是不仅要长度更长，同时元素的值相对更“矮”，这样能为后续构建更长的子序列提供更多可能性。\",\"取代栈内的值：当找到合适位置时，用新元素替换栈内相应位置的元素，优化栈的结构。\",\"for(int i=1;i<=n;++i) { int pos=lower_bound(stk+1,stk+1+top,a[i])-stk; /*找到第一个大于等于a[i]的位置,注意，严格上升!如果是等元素则返回的是栈顶也就不会是top+1,如果题目说的是 不降则就要找到第一个大于a[i]的位置取代,届时用upper_bound即可*/ if(pos==top+1)top++;//如果长度比top更长就取代这个位置,这一行是更新最大长度 stk[pos]=a[i];//取代 ans=max(ans,top); }\"]},\"45\":{\"h\":\"狄尔沃斯定理\",\"t\":[\"狄尔沃斯定理为我们理解最长上升子序列及其相关概念提供了新的视角，具体内容如下：\",\"最长不升子序列的最小覆盖数等于最长上升子序列的长度。\",\"最长不降子序列的最小覆盖数等于最长下降子序列的长度。\",\"这个定理建立了不同类型子序列之间的内在联系，有助于我们更深入地理解序列的结构和性质，在解决相关问题时提供了有力的理论支持。\"]},\"46\":{\"c\":[\"Longest Increasing Subsequence(最长上升子序列）\"]},\"47\":{\"h\":\"ACM\"},\"48\":{\"c\":[\"ACM\"]},\"49\":{\"h\":\"Search (搜索)\"},\"50\":{\"h\":\"搜素专题\",\"t\":[\"原文oi wiki:DFSBFS\"]},\"51\":{\"h\":\"1.dfs\",\"t\":[\"子集型:枚举0101,即选或者不选. 排列型:123 132 231 213这样在已知个数的情况下枚举排列顺序\",\"DFS基于栈\"]},\"52\":{\"h\":\"2.bfs\",\"t\":[\"等权最短路:在无权图或等权图中，BFS 可以找到从起点到终点的最短路径。 最少操作次数:在状态转移问题中，BFS 可以找到从初始状态到目标状态的最少操作次数。\",\"BFS基于队列\"]},\"53\":{\"c\":[\"Search (搜索)\"]},\"54\":{\"h\":\"string(字符串)\",\"t\":[\"原文oi wiki:string\"]},\"55\":{\"h\":\"\",\"t\":[\"后缀是指从某个位置 i 开始到整个串末尾结束的一个特殊子串。字符串 S 的从 i 开头的后缀表示为 Suffix(S,i)，也就是 Suffix(S,i)=S[i..∣S∣−1]。\",\"真后缀：除去 S 本身的所有后缀。\",\"前缀 同理。\"]},\"56\":{\"h\":\"\",\"t\":[\"前缀是指从串首开始到某个位置 i 结束的一个特殊子串。字符串 S 的以 i 结尾的前缀表示为 Prefix(S,i)，也就是 Prefix(S,i)=S[0..i]。\",\"若字符串满足 s[l]=s[∣s∣+1−i]，则称其为正反写相同的字符串，即回文串。\",\"字符串本质上是一个 char 数组，用 空字符 \\\\0 作为尾标。\"]},\"57\":{\"h\":\"\",\"t\":[\"find(ch, start = 0)：查找并返回从 start 开始的字符 ch 的位置（位置从 0 开始计数）。若查找不到，返回 -1。\",\"rfind(ch)：从末尾开始查找，并返回第一个找到的字符 ch 的位置（位置从 0 开始计数）。若查找不到，返回 -1。\"]},\"58\":{\"h\":\"\",\"t\":[\"substr(start, len)：从字符串的 start 位置（从 0 开始）截取一个长度为 len 的字符串。若缺省 len，则截取到字符串末尾。\",\"append(s)：将字符串 s 添加到当前字符串末尾。\"]},\"59\":{\"h\":\"\",\"t\":[\"replace 方法有两种常见用法：\",\"replace(pos, n, s)：将字符串从 pos 开始的 n 个字符替换为字符串 s。\",\"replace(pos, n, s)：先删除从 pos 开始的 n 个字符，然后在 pos 处插入字符串 s。\"]},\"60\":{\"h\":\"\",\"t\":[\"erase(pos, n)：删除从 pos 开始的 n 个字符。\",\"insert(pos, s)：在 pos 位置插入字符串 s。\"]},\"61\":{\"h\":\"\",\"t\":[\"std::string 重载了比较运算符，其时间复杂度为 Θ(N)。\"]},\"62\":{\"c\":[\"string(字符串)\"]},\"63\":{\"h\":\"Back\"},\"64\":{\"c\":[\"Back\"]},\"65\":{\"h\":\"Front\"},\"66\":{\"c\":[\"Front\"]},\"67\":{\"h\":\"Vue\"},\"68\":{\"c\":[\"Vue\"]},\"69\":{\"h\":\"Layout\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"70\":{\"c\":[\"Layout\"]},\"71\":{\"h\":\"Markdown\"},\"72\":{\"h\":\"基础知识\",\"t\":[\"# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题\",\"[网站名称](网站链接) <!-- 像这样 --> [lolol](www.baidu.com)\"]},\"73\":{\"h\":\"vuepress扩展\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"74\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"75\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"76\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"77\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"78\":{\"h\":\"主题扩展\",\"t\":[\"通过 VuePress 插件，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"79\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"80\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"81\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"82\":{\"h\":\"TeX 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"83\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"84\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"85\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"86\":{\"h\":\"组件\"},\"87\":{\"c\":[\"Markdown\"]},\"88\":{\"h\":\"Page\",\"t\":[\"hehehe\"]},\"89\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"90\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南” 你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"<!-- 禁用导航栏 --> navbar: false <!-- 禁用侧边栏 --> sidebar: false <!-- 禁用路径导航 --> breadcrumb: false <!-- 禁用页面信息 --> pageInfo: false <!-- 禁用贡献者 --> contributors: false <!-- 禁用编辑此页链接 --> editLink: false <!-- 禁用更新时间 --> lastUpdated: false <!-- 禁用上一篇链接 --> prev: false <!-- 禁用下一篇链接 --> next: false <!-- 禁用评论 --> comment: false <!-- 禁用页脚 --> footer: false <!-- 禁用返回顶部按钮 --> backtotop: false\"]},\"91\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"92\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"93\":{\"c\":[\"Page\"]},\"94\":{\"h\":\"Linux\"},\"95\":{\"c\":[\"Linux\"]},\"96\":{\"h\":\"Shell\"},\"97\":{\"c\":[\"Shell\"]},\"98\":{\"h\":\"Other\"},\"99\":{\"c\":[\"Other\"]},\"100\":{\"h\":\"Git\"},\"101\":{\"h\":\"git基础\",\"t\":[\"我很推荐在游玩中学习关于git的知识:git小游戏 所以接下来的是一些git的指令，旨在忘记的时候方便查询(当然，熟能生巧)\"]},\"102\":{\"h\":\"git指令(基础命令)\",\"t\":[\"git commit 创建一个新的提交记录\",\"git branch name 创建一个分支 git checkout name切换到某一个分支(或指针) git checkout -b name 创建并切换到某一个分支 git branch -f name place 在某个节点创建分支 git checkout -b name place在某个节点创建分支并转移到该节点\",\"git merge name 把某一个分支合并到当前指针的内容并产生一个新的分支\",\"git rebase name 把当前指针的内容合并到某一个分支并创建一个新的分支,原分支还在，此方法更加线性\",\"^,回到其所指的parent,如:HEAD^,HEAD^^,C1^ 。~,回到第n个parent,如:HEAD~4 -f强制移动，可以往后移动 git branch -f a b强制把a移动到b\",\"git reset name撤销到某一个分支 git revert name撤销到某一个分支并产生一个新的分支\",\"git cherry-pick name将某一个分支的复制提交在当前指针下 git cherry-pick a b c ...将某一个从a到b到分支的复制提交到当前指针下\",\"git rebase -i name 打开一个交互式界面，对指定节点的子节点进行操作 undo,reset来修正错误 git rebase a b 把b节点合并到a\",\"git describe name 查找某一个节点最近的tag\"]},\"103\":{\"h\":\"git指令(远程)\",\"t\":[\"git clone 创建一个远程仓库 name/main :仓库名称/分支名称\",\"git fetch 获取远程仓库的数据(不会占用你的磁盘空间);在你运行之后name/main会移动到远程仓库的main处\",\"git pull 等同于fetch + merge，即先获取你的远端仓库数据再合并到你的本地仓库 --rebase等同于pull +rebase,rebase是线性的!\",\"git push 将本地仓库上传到远程仓库，在你运行之后远程仓库的main会移动到本地仓库的o/main处\",\"git checkout -b name o/main你把一个从未见过的name分支作为远程跟踪o/main,此时main就变成普通的分支被抛弃了QAQ git branch -u o/main name同上，如果你当前在name上还可以省略name\",\"git push origin main :切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。\",\"git push originsource:destination这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 foo 或者 HEAD~1）\",\"git fetch originsource:destination这里有一点是需要注意的 —— source 现在指的是远程仓库中的位置，而 destination 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。\",\"当source为空时push会删除destination的分支，而相反fetch会新增分支!\",\"git pull也就当成是fetch，就是多了个merge而已:D\"]},\"104\":{\"c\":[\"Git\"]},\"105\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"106\":{\"h\":\"分类\"},\"107\":{\"c\":[\"分类\"]},\"108\":{\"h\":\"算法知识 分类\"},\"109\":{\"c\":[\"算法知识 分类\"]},\"110\":{\"h\":\"使用指南 分类\"},\"111\":{\"c\":[\"使用指南 分类\"]},\"112\":{\"h\":\"标签\"},\"113\":{\"c\":[\"标签\"]},\"114\":{\"h\":\"标签: 知识点\"},\"115\":{\"c\":[\"标签: 知识点\"]},\"116\":{\"h\":\"标签: 布局\"},\"117\":{\"c\":[\"标签: 布局\"]},\"118\":{\"h\":\"文章\"},\"119\":{\"c\":[\"文章\"]},\"120\":{\"h\":\"星标\"},\"121\":{\"c\":[\"星标\"]},\"122\":{\"h\":\"时间轴\"},\"123\":{\"c\":[\"时间轴\"]}},\"dirtCount\":0,\"index\":[[\"星标\",{\"0\":{\"120\":1},\"2\":{\"121\":1}}],[\"布局\",{\"0\":{\"116\":1},\"2\":{\"117\":1}}],[\"布局包括\",{\"1\":{\"69\":1}}],[\"知识点\",{\"0\":{\"114\":1},\"2\":{\"115\":1}}],[\"算法知识\",{\"0\":{\"108\":1},\"2\":{\"109\":1}}],[\"就是多了个merge而已\",{\"1\":{\"103\":1}}],[\"刚好相反\",{\"1\":{\"103\":1}}],[\"它与\",{\"1\":{\"103\":1}}],[\"才是要放置提交的本地仓库的位置\",{\"1\":{\"103\":1}}],[\"才能找出真正的最长上升子序列长度\",{\"1\":{\"40\":1}}],[\"现在指的是远程仓库中的位置\",{\"1\":{\"103\":1}}],[\"或者\",{\"1\":{\"103\":1}}],[\"或指针\",{\"1\":{\"102\":1}}],[\"能识别的位置\",{\"1\":{\"103\":1}}],[\"意思是\",{\"1\":{\"103\":1}}],[\"搞定之后告诉我\",{\"1\":{\"103\":1}}],[\"获取所有的提交\",{\"1\":{\"103\":1}}],[\"获取远程仓库的数据\",{\"1\":{\"103\":1}}],[\"切到本地仓库中的\",{\"1\":{\"103\":1}}],[\"等同于fetch\",{\"1\":{\"103\":1}}],[\"等权最短路\",{\"1\":{\"52\":1}}],[\"仓库名称\",{\"1\":{\"103\":1}}],[\"远程\",{\"0\":{\"103\":1}}],[\"u\",{\"1\":{\"103\":1}}],[\"undo\",{\"1\":{\"102\":1}}],[\"update\",{\"1\":{\"21\":1}}],[\"打开一个交互式界面\",{\"1\":{\"102\":1}}],[\"打印按钮\",{\"1\":{\"69\":1}}],[\"回到第n个parent\",{\"1\":{\"102\":1}}],[\"回到其所指的parent\",{\"1\":{\"102\":1}}],[\"~\",{\"1\":{\"102\":1}}],[\"^\",{\"1\":{\"102\":1}}],[\"原分支还在\",{\"1\":{\"102\":1}}],[\"原文oi\",{\"1\":{\"3\":1,\"9\":1,\"14\":1,\"23\":1,\"26\":1,\"39\":1,\"50\":1,\"54\":1}}],[\"把b节点合并到a\",{\"1\":{\"102\":1}}],[\"把当前指针的内容合并到某一个分支并创建一个新的分支\",{\"1\":{\"102\":1}}],[\"把某一个分支合并到当前指针的内容并产生一个新的分支\",{\"1\":{\"102\":1}}],[\"创建并切换到某一个分支\",{\"1\":{\"102\":1}}],[\"创建一个远程仓库\",{\"1\":{\"103\":1}}],[\"创建一个分支\",{\"1\":{\"102\":1}}],[\"创建一个新的提交记录\",{\"1\":{\"102\":1}}],[\"创建原数组的副本\",{\"1\":{\"16\":1}}],[\"基础命令\",{\"0\":{\"102\":1}}],[\"基础知识\",{\"0\":{\"72\":1}}],[\"熟能生巧\",{\"1\":{\"101\":1}}],[\"旨在忘记的时候方便查询\",{\"1\":{\"101\":1}}],[\"所以接下来的是一些git的指令\",{\"1\":{\"101\":1}}],[\"我很推荐在游玩中学习关于git的知识\",{\"1\":{\"101\":1}}],[\"我们要牢记三个核心要点\",{\"1\":{\"44\":1}}],[\"我们能够动态地更新最长上升子序列的长度\",{\"1\":{\"44\":1}}],[\"我们能够快速定位当前元素在栈中应该插入的位置\",{\"1\":{\"42\":1}}],[\"我们将\",{\"1\":{\"43\":1}}],[\"我们用\",{\"1\":{\"43\":1}}],[\"我们运用二分查找算法在单调栈\",{\"1\":{\"43\":1}}],[\"我们维护一个单调递增的栈\",{\"1\":{\"42\":1}}],[\"我们需要遍历整个结果数组\",{\"1\":{\"40\":1}}],[\"我们引入两个关键变量\",{\"1\":{\"40\":1}}],[\"我们实际上是用两个树状数组来维护\",{\"1\":{\"21\":1}}],[\"我们一般会进行深度优先搜索\",{\"1\":{\"12\":1}}],[\"进行引用\",{\"1\":{\"91\":1}}],[\"图片引入\",{\"1\":{\"91\":1}}],[\"图片增强\",{\"0\":{\"84\":1}}],[\"禁用返回顶部按钮\",{\"1\":{\"90\":1}}],[\"禁用页脚\",{\"1\":{\"90\":1}}],[\"禁用页面信息\",{\"1\":{\"90\":1}}],[\"禁用评论\",{\"1\":{\"90\":1}}],[\"禁用下一篇链接\",{\"1\":{\"90\":1}}],[\"禁用上一篇链接\",{\"1\":{\"90\":1}}],[\"禁用更新时间\",{\"1\":{\"90\":1}}],[\"禁用编辑此页链接\",{\"1\":{\"90\":1}}],[\"禁用贡献者\",{\"1\":{\"90\":1}}],[\"禁用路径导航\",{\"1\":{\"90\":1}}],[\"禁用侧边栏\",{\"1\":{\"90\":1}}],[\"禁用导航栏\",{\"1\":{\"90\":1}}],[\"标签\",{\"0\":{\"112\":1,\"114\":1,\"116\":1},\"2\":{\"113\":1,\"115\":1,\"117\":1}}],[\"标签为\",{\"1\":{\"90\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"89\":1}}],[\"标题和页面信息\",{\"1\":{\"69\":1}}],[\"使用指南\",{\"0\":{\"110\":1},\"1\":{\"90\":2},\"2\":{\"111\":1}}],[\"日\",{\"1\":{\"90\":1}}],[\"月\",{\"1\":{\"90\":1}}],[\"年\",{\"1\":{\"90\":1}}],[\"写作日期为\",{\"1\":{\"90\":1}}],[\"作者设置为\",{\"1\":{\"90\":1}}],[\"作为尾标\",{\"1\":{\"56\":1}}],[\"组件\",{\"0\":{\"86\":1,\"92\":1},\"1\":{\"92\":1}}],[\"组合数\",{\"0\":{\"2\":1,\"3\":1},\"1\":{\"3\":1},\"2\":{\"7\":1}}],[\"head~1\",{\"1\":{\"103\":1}}],[\"head~4\",{\"1\":{\"102\":1}}],[\"head^^\",{\"1\":{\"102\":1}}],[\"head^\",{\"1\":{\"102\":1}}],[\"hehehe\",{\"1\":{\"88\":1}}],[\"hope\",{\"1\":{\"90\":1}}],[\"home\",{\"0\":{\"0\":1},\"2\":{\"1\":1}}],[\"h1\",{\"1\":{\"89\":2}}],[\"h2o\",{\"1\":{\"85\":1}}],[\"上下角标\",{\"0\":{\"85\":1}}],[\"上的某种性质\",{\"1\":{\"11\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"84\":1}}],[\"计划\",{\"1\":{\"83\":2}}],[\"计算组合数\",{\"1\":{\"5\":1,\"6\":1}}],[\"计算阶乘的逆元\",{\"1\":{\"5\":1}}],[\"计算阶乘\",{\"1\":{\"5\":1}}],[\"计算\",{\"1\":{\"5\":1}}],[\"任务列表\",{\"0\":{\"83\":1}}],[\"−1\",{\"1\":{\"82\":1}}],[\"−i=1∑r​di​×i\",{\"1\":{\"21\":1}}],[\"ωyω​\",{\"1\":{\"82\":2}}],[\"∂ωr∂r​\",{\"1\":{\"82\":1}}],[\"导入文件\",{\"0\":{\"81\":1}}],[\"导航栏\",{\"1\":{\"69\":1}}],[\"此时main就变成普通的分支被抛弃了qaq\",{\"1\":{\"103\":1}}],[\"此方法更加线性\",{\"1\":{\"102\":1}}],[\"此方法先预处理阶乘和逆元\",{\"1\":{\"5\":1}}],[\"此文字有脚注^first\",{\"1\":{\"80\":1}}],[\"脚注\",{\"0\":{\"80\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"78\":1}}],[\"插件\",{\"1\":{\"78\":1}}],[\"插件来实现\",{\"1\":{\"76\":1}}],[\"关于这些扩展\",{\"1\":{\"77\":1}}],[\"语法\",{\"0\":{\"82\":1},\"1\":{\"78\":1,\"92\":1}}],[\"语法进行了扩展\",{\"1\":{\"77\":1}}],[\"语法扩展\",{\"1\":{\"76\":1}}],[\"对指定节点的子节点进行操作\",{\"1\":{\"102\":1}}],[\"对于\",{\"1\":{\"91\":1}}],[\"对于序列中的每个元素\",{\"1\":{\"43\":1}}],[\"对\",{\"1\":{\"77\":1}}],[\"为了丰富文档写作\",{\"1\":{\"77\":1}}],[\"为每个\",{\"1\":{\"75\":1}}],[\"内容\",{\"1\":{\"76\":1}}],[\"来解析\",{\"1\":{\"76\":1}}],[\"来遍历树的节点\",{\"1\":{\"12\":1}}],[\"会使用\",{\"1\":{\"76\":1}}],[\"扩展\",{\"0\":{\"76\":1,\"77\":1},\"1\":{\"77\":1}}],[\"了解详情\",{\"1\":{\"75\":1}}],[\"请使用绝对链接\",{\"1\":{\"91\":1}}],[\"请阅读\",{\"1\":{\"75\":1,\"77\":1}}],[\"请先阅读\",{\"1\":{\"74\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"92\":1}}],[\"页面内容\",{\"0\":{\"91\":1}}],[\"页面配置\",{\"1\":{\"90\":1}}],[\"页面信息\",{\"0\":{\"90\":1}}],[\"页面标题\",{\"0\":{\"89\":1},\"1\":{\"89\":1}}],[\"页面引入配置\",{\"1\":{\"75\":1}}],[\"页脚\",{\"1\":{\"69\":1}}],[\"配置\",{\"0\":{\"75\":1}}],[\"演示\",{\"1\":{\"74\":1}}],[\"还不会编写\",{\"1\":{\"74\":1}}],[\"介绍\",{\"0\":{\"74\":1},\"1\":{\"74\":1,\"75\":1}}],[\"以便\",{\"1\":{\"73\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"92\":1}}],[\"你需要创建并编写\",{\"1\":{\"73\":1}}],[\"你可以将图片和\",{\"1\":{\"91\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"91\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"90\":1}}],[\"你可以在\",{\"1\":{\"89\":1,\"90\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"69\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"73\":1}}],[\"文章\",{\"0\":{\"118\":1},\"2\":{\"119\":1}}],[\"文章标题列表\",{\"1\":{\"69\":1}}],[\"文件夹的图片\",{\"1\":{\"91\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"91\":1}}],[\"文件生成页面\",{\"1\":{\"73\":1}}],[\"主题扩展了更多\",{\"1\":{\"78\":1}}],[\"主题扩展\",{\"0\":{\"78\":1}}],[\"主题也带有以下元素\",{\"1\":{\"69\":1}}],[\"主要从\",{\"1\":{\"73\":1}}],[\"像这样\",{\"1\":{\"72\":1}}],[\"网站链接\",{\"1\":{\"72\":1}}],[\"网站名称\",{\"1\":{\"72\":1}}],[\"六级标题\",{\"1\":{\"72\":1}}],[\"五级标题\",{\"1\":{\"72\":1}}],[\"四级标题\",{\"1\":{\"72\":1}}],[\"三级标题\",{\"1\":{\"72\":1}}],[\"一级标题\",{\"1\":{\"72\":1}}],[\"一共放了\",{\"1\":{\"10\":1}}],[\"夜间模式按钮\",{\"1\":{\"69\":1}}],[\"评论\",{\"1\":{\"69\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"69\":1}}],[\"更长则更新\",{\"1\":{\"44\":1}}],[\"贡献者\",{\"1\":{\"69\":1}}],[\"路径导航\",{\"1\":{\"69\":1}}],[\"侧边栏\",{\"1\":{\"69\":1}}],[\"θ\",{\"1\":{\"61\":1}}],[\"重载了比较运算符\",{\"1\":{\"61\":1}}],[\"删除从\",{\"1\":{\"60\":1}}],[\"editlink\",{\"1\":{\"90\":1}}],[\"erase\",{\"1\":{\"60\":1}}],[\"else\",{\"1\":{\"5\":1,\"28\":1,\"29\":1,\"30\":1,\"32\":1}}],[\"处插入字符串\",{\"1\":{\"59\":1}}],[\"处理特殊情况\",{\"1\":{\"5\":1}}],[\"然后在\",{\"1\":{\"59\":1}}],[\"添加到当前字符串末尾\",{\"1\":{\"58\":1}}],[\"截取一个长度为\",{\"1\":{\"58\":1}}],[\"位置插入字符串\",{\"1\":{\"60\":1}}],[\"位置\",{\"1\":{\"58\":1}}],[\"位置从\",{\"1\":{\"57\":2}}],[\"返回顶部按钮\",{\"1\":{\"69\":1}}],[\"返回\",{\"1\":{\"57\":2}}],[\"查找某一个节点最近的tag\",{\"1\":{\"102\":1}}],[\"查找并返回从\",{\"1\":{\"57\":1}}],[\"查看详情\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"查询\",{\"1\":{\"18\":1}}],[\"空字符\",{\"1\":{\"56\":1}}],[\"空间为\",{\"1\":{\"28\":1,\"32\":1}}],[\"空间足够时使用快速幂\",{\"0\":{\"5\":1}}],[\"则截取到字符串末尾\",{\"1\":{\"58\":1}}],[\"则称其为正反写相同的字符串\",{\"1\":{\"56\":1}}],[\"则作为连接点\",{\"1\":{\"40\":1}}],[\"∣s∣+1−i\",{\"1\":{\"56\":1}}],[\"∣s∣−1\",{\"1\":{\"55\":1}}],[\"结尾的前缀表示为\",{\"1\":{\"56\":1}}],[\"结束的一个特殊子串\",{\"1\":{\"56\":1}}],[\"前缀是指从串首开始到某个位置\",{\"1\":{\"56\":1}}],[\"前缀\",{\"1\":{\"55\":1}}],[\"本身的所有后缀\",{\"1\":{\"55\":1}}],[\"除去\",{\"1\":{\"55\":1}}],[\"真后缀\",{\"1\":{\"55\":1}}],[\"也就是\",{\"1\":{\"55\":1,\"56\":1}}],[\"也可以使用\",{\"1\":{\"17\":1}}],[\"开始的\",{\"1\":{\"59\":2,\"60\":1}}],[\"开始的字符\",{\"1\":{\"57\":1}}],[\"开始\",{\"1\":{\"58\":1}}],[\"开始计数\",{\"1\":{\"57\":2}}],[\"开始到整个串末尾结束的一个特殊子串\",{\"1\":{\"55\":1}}],[\"开头的后缀表示为\",{\"1\":{\"55\":1}}],[\"后缀是指从某个位置\",{\"1\":{\"55\":1}}],[\"字符串本质上是一个\",{\"1\":{\"56\":1}}],[\"字符串\",{\"0\":{\"54\":1},\"1\":{\"55\":1,\"56\":1},\"2\":{\"62\":1}}],[\"最少操作次数\",{\"1\":{\"52\":1}}],[\"最长不降子序列的最小覆盖数等于最长下降子序列的长度\",{\"1\":{\"45\":1}}],[\"最长不升子序列的最小覆盖数等于最长上升子序列的长度\",{\"1\":{\"45\":1}}],[\"最长上升子序列\",{\"0\":{\"39\":1},\"2\":{\"46\":1}}],[\"排列型\",{\"1\":{\"51\":1}}],[\"枚举0101\",{\"1\":{\"51\":1}}],[\"子集型\",{\"1\":{\"51\":1}}],[\"搜素专题\",{\"0\":{\"50\":1}}],[\"搜索\",{\"0\":{\"49\":1},\"2\":{\"53\":1}}],[\"有助于我们更深入地理解序列的结构和性质\",{\"1\":{\"45\":1}}],[\"具体内容如下\",{\"1\":{\"45\":1}}],[\"狄尔沃斯定理为我们理解最长上升子序列及其相关概念提供了新的视角\",{\"1\":{\"45\":1}}],[\"狄尔沃斯定理\",{\"0\":{\"45\":1}}],[\"届时用upper\",{\"1\":{\"44\":1}}],[\"严格上升\",{\"1\":{\"44\":1}}],[\"找到第一个大于等于a\",{\"1\":{\"44\":1}}],[\"优化栈的结构\",{\"1\":{\"44\":1}}],[\"优化到\",{\"1\":{\"6\":1}}],[\"用\",{\"1\":{\"56\":1}}],[\"用新元素替换栈内相应位置的元素\",{\"1\":{\"44\":1}}],[\"用于计算快速幂\",{\"1\":{\"6\":1}}],[\"取代\",{\"1\":{\"44\":1}}],[\"取代栈内的值\",{\"1\":{\"44\":1}}],[\"取模的结果\",{\"1\":{\"5\":1}}],[\"矮\",{\"1\":{\"44\":1}}],[\"要及时更新相关信息\",{\"1\":{\"44\":1}}],[\"准确运用二分查找确定元素在栈中的合适位置\",{\"1\":{\"44\":1}}],[\"动态规划\",{\"0\":{\"44\":1}}],[\"动态规划计算组合数\",{\"1\":{\"4\":1}}],[\"逐步逼近最长上升子序列\",{\"1\":{\"43\":1}}],[\"压入栈中\",{\"1\":{\"43\":1}}],[\"压缩成一维\",{\"1\":{\"30\":1}}],[\"大于栈内所有元素\",{\"1\":{\"43\":1}}],[\"大的元素\",{\"1\":{\"24\":2}}],[\"若缺省\",{\"1\":{\"58\":1}}],[\"若查找不到\",{\"1\":{\"57\":2}}],[\"若字符串满足\",{\"1\":{\"56\":1}}],[\"若不存在这样的位置\",{\"1\":{\"43\":1}}],[\"若该位置位于栈内\",{\"1\":{\"43\":1}}],[\"替换此位置的元素\",{\"1\":{\"43\":1}}],[\"二级标题\",{\"1\":{\"72\":1}}],[\"二分查找位置\",{\"1\":{\"44\":1}}],[\"二分查找\",{\"0\":{\"43\":1}}],[\"二进制优化的核心思想是\",{\"1\":{\"37\":1}}],[\"借助这一特性\",{\"1\":{\"42\":1}}],[\"栈的关键特性在于其中的元素始终保持单调递增\",{\"1\":{\"42\":1}}],[\"单调栈\",{\"0\":{\"42\":1}}],[\"单调栈二分动态规划核心思想\",{\"0\":{\"41\":1}}],[\"单点修改\",{\"0\":{\"20\":1},\"1\":{\"18\":2}}],[\"困难情形\",{\"0\":{\"41\":1}}],[\"需要特别注意的是\",{\"1\":{\"40\":1}}],[\"在你运行之后远程仓库的main会移动到本地仓库的o\",{\"1\":{\"103\":1}}],[\"在你运行之后name\",{\"1\":{\"103\":1}}],[\"在某个节点创建分支\",{\"1\":{\"102\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"90\":1}}],[\"在\",{\"1\":{\"60\":1}}],[\"在状态转移问题中\",{\"1\":{\"52\":1}}],[\"在无权图或等权图中\",{\"1\":{\"52\":1}}],[\"在解决相关问题时提供了有力的理论支持\",{\"1\":{\"45\":1}}],[\"在整个过程中\",{\"1\":{\"44\":1}}],[\"在得出所有以不同元素结尾的最长上升子序列长度后\",{\"1\":{\"40\":1}}],[\"在构建最长上升子序列的过程中起着重要作用\",{\"1\":{\"40\":1}}],[\"在最长上升子序列问题中\",{\"1\":{\"40\":1}}],[\"在树形\",{\"1\":{\"12\":1}}],[\"简单情形\",{\"0\":{\"40\":1}}],[\"且物品数量大大减少\",{\"1\":{\"37\":1}}],[\"且状态转移依赖于更小的子区间\",{\"1\":{\"11\":1}}],[\"且状态转移是线性的\",{\"1\":{\"10\":1}}],[\"个字符\",{\"1\":{\"59\":1,\"60\":1}}],[\"个字符替换为字符串\",{\"1\":{\"59\":1}}],[\"个物品\",{\"1\":{\"37\":2}}],[\"个元素\",{\"1\":{\"28\":1,\"32\":1}}],[\"再到远程仓库\",{\"1\":{\"103\":1}}],[\"再加上剩余的部分\",{\"1\":{\"37\":1}}],[\"再根据组合数公式计算组合数\",{\"1\":{\"5\":1}}],[\"8\",{\"1\":{\"37\":1}}],[\"404\",{\"1\":{\"105\":1}}],[\"4\",{\"1\":{\"37\":1}}],[\"4e18\",{\"1\":{\"11\":1}}],[\"如果你当前在name上还可以省略name\",{\"1\":{\"103\":1}}],[\"如果你是一个新手\",{\"1\":{\"74\":1}}],[\"如果长度比top更长就取代这个位置\",{\"1\":{\"44\":1}}],[\"如果题目说的是\",{\"1\":{\"44\":1}}],[\"如果是等元素则返回的是栈顶也就不会是top+1\",{\"1\":{\"44\":1}}],[\"如果从左往右遍历\",{\"1\":{\"30\":1}}],[\"如\",{\"1\":{\"37\":1,\"102\":2}}],[\"拆分成若干个\",{\"1\":{\"37\":1}}],[\"次获取的机会\",{\"1\":{\"35\":1}}],[\"次方对\",{\"1\":{\"5\":1}}],[\"多重背包问题被转化为\",{\"1\":{\"37\":1}}],[\"多重背包\",{\"0\":{\"35\":1}}],[\"花费空间为\",{\"1\":{\"34\":1}}],[\"已经包含了当前物品可能被选择多次的情况\",{\"1\":{\"34\":1}}],[\"已经在当前轮次被更新过\",{\"1\":{\"30\":1,\"34\":1}}],[\"时间轴\",{\"0\":{\"122\":1},\"2\":{\"123\":1}}],[\"时\",{\"1\":{\"34\":1}}],[\"每种物品的数量\",{\"1\":{\"37\":1}}],[\"每次更新\",{\"1\":{\"34\":1}}],[\"每个\",{\"1\":{\"92\":1}}],[\"每个物品可以选择多次\",{\"1\":{\"34\":1}}],[\"每个物品只能选一次\",{\"1\":{\"30\":1}}],[\"每个物品只能获取一次\",{\"1\":{\"27\":1}}],[\"每个状态表示一个区间\",{\"1\":{\"11\":1}}],[\"每个状态只依赖于前一个或前几个状态\",{\"1\":{\"10\":1}}],[\"同理\",{\"1\":{\"55\":1}}],[\"同时每个页面包含\",{\"1\":{\"69\":1}}],[\"同时元素的值相对更\",{\"1\":{\"44\":1}}],[\"同时记录每个元素出现的位置\",{\"1\":{\"16\":1}}],[\"同上\",{\"1\":{\"33\":1}}],[\"选项卡\",{\"0\":{\"79\":1}}],[\"选若干个\",{\"1\":{\"32\":1}}],[\"选前\",{\"1\":{\"28\":1}}],[\"无穷背包\",{\"0\":{\"31\":1}}],[\"违反了\",{\"1\":{\"30\":1}}],[\"小\",{\"1\":{\"30\":1,\"34\":1}}],[\"比如分支\",{\"1\":{\"103\":1}}],[\"比\",{\"1\":{\"30\":1,\"34\":1}}],[\"可以往后移动\",{\"1\":{\"102\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"73\":1}}],[\"可以找到从初始状态到目标状态的最少操作次数\",{\"1\":{\"52\":1}}],[\"可以找到从起点到终点的最短路径\",{\"1\":{\"52\":1}}],[\"可以被拆分成\",{\"1\":{\"37\":1}}],[\"可以使用快速幂的方法来计算组合数\",{\"1\":{\"5\":1}}],[\"可以使用动态规划的方式计算组合数\",{\"1\":{\"4\":1}}],[\"可能会被更新多次\",{\"1\":{\"30\":1,\"34\":1}}],[\"y^1\",{\"1\":{\"29\":3}}],[\"y\",{\"1\":{\"29\":4,\"33\":1}}],[\"采用\",{\"1\":{\"29\":1}}],[\"只考虑前后关系\",{\"1\":{\"29\":1}}],[\"因为我们在往相反的方向传送数据\",{\"1\":{\"103\":1}}],[\"因为我们的\",{\"1\":{\"29\":1}}],[\"因为\",{\"1\":{\"30\":1,\"34\":1}}],[\"因此可以借助于\",{\"1\":{\"76\":1}}],[\"因此我们可以只维护当前和前一项这两种状态\",{\"1\":{\"29\":1}}],[\"因此\",{\"1\":{\"21\":1,\"73\":1}}],[\"背包问题\",{\"1\":{\"37\":1}}],[\"背包中\",{\"1\":{\"30\":1}}],[\"背包不考虑方案整体\",{\"1\":{\"29\":1}}],[\"背包\",{\"0\":{\"27\":1}}],[\"背包dp\",{\"0\":{\"26\":1},\"1\":{\"26\":1},\"2\":{\"38\":1}}],[\"表达式\",{\"1\":{\"24\":1}}],[\"表示以其作为结尾的最长上升子序列的长度\",{\"1\":{\"40\":1}}],[\"表示\",{\"1\":{\"12\":1}}],[\"不会占用你的磁盘空间\",{\"1\":{\"103\":1}}],[\"不降则就要找到第一个大于a\",{\"1\":{\"44\":1}}],[\"不断优化栈内元素\",{\"1\":{\"43\":1}}],[\"不重复\",{\"1\":{\"24\":1}}],[\"不能越界\",{\"1\":{\"20\":1}}],[\"不能用\",{\"1\":{\"18\":1}}],[\"∑ai​bj​\",{\"1\":{\"24\":1}}],[\"求\",{\"1\":{\"24\":1}}],[\"问题\",{\"1\":{\"24\":1}}],[\"⋯\",{\"1\":{\"24\":2}}],[\"序列\",{\"1\":{\"24\":2}}],[\"序列定义\",{\"1\":{\"24\":1}}],[\"贪心策略\",{\"0\":{\"24\":1}}],[\"贪心\",{\"0\":{\"23\":1},\"1\":{\"23\":1},\"2\":{\"25\":1}}],[\"git指令\",{\"0\":{\"102\":1,\"103\":1}}],[\"git小游戏\",{\"1\":{\"101\":1}}],[\"git基础\",{\"0\":{\"101\":1}}],[\"git\",{\"0\":{\"100\":1},\"1\":{\"102\":16,\"103\":12},\"2\":{\"104\":1}}],[\"greedy\",{\"0\":{\"23\":1},\"2\":{\"25\":1}}],[\"getsum\",{\"1\":{\"19\":1,\"21\":2}}],[\"到目前为止\",{\"1\":{\"34\":1}}],[\"到\",{\"1\":{\"21\":1}}],[\"到第\",{\"1\":{\"10\":2}}],[\"都是\",{\"1\":{\"21\":1}}],[\"都为\",{\"1\":{\"4\":1}}],[\"实际上等同于\",{\"1\":{\"21\":1}}],[\"实现的\",{\"1\":{\"21\":1}}],[\"这是可以讲的通的\",{\"1\":{\"103\":1}}],[\"这意味着你可以在\",{\"1\":{\"92\":1}}],[\"这一行是更新最大长度\",{\"1\":{\"44\":1}}],[\"这个定理建立了不同类型子序列之间的内在联系\",{\"1\":{\"45\":1}}],[\"这个栈用于存储当前有可能构成最长上升子序列的元素\",{\"1\":{\"42\":1}}],[\"这个操作\",{\"1\":{\"21\":1}}],[\"这里强调的是不仅要长度更长\",{\"1\":{\"44\":1}}],[\"这里\",{\"1\":{\"40\":1}}],[\"这里的\",{\"1\":{\"21\":1}}],[\"这样能为后续构建更长的子序列提供更多可能性\",{\"1\":{\"44\":1}}],[\"这样\",{\"1\":{\"37\":1}}],[\"这样正好符合完全背包中\",{\"1\":{\"34\":1}}],[\"这样会导致一个物品被多次选择\",{\"1\":{\"30\":1}}],[\"这两种状态存储\",{\"1\":{\"29\":1}}],[\"r−i​\",{\"1\":{\"82\":1}}],[\"r−i+1\",{\"1\":{\"82\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"82\":1}}],[\"r+1\",{\"1\":{\"21\":1}}],[\"rfind\",{\"1\":{\"57\":1}}],[\"r\",{\"1\":{\"21\":1}}],[\"refspec\",{\"1\":{\"103\":2}}],[\"revert\",{\"1\":{\"102\":1}}],[\"rebase是线性的\",{\"1\":{\"103\":1}}],[\"rebase等同于pull\",{\"1\":{\"103\":1}}],[\"rebase\",{\"1\":{\"102\":3}}],[\"regarded\",{\"1\":{\"89\":1}}],[\"replace\",{\"1\":{\"59\":3}}],[\"return\",{\"1\":{\"5\":3,\"17\":2,\"19\":1,\"21\":1}}],[\"reset来修正错误\",{\"1\":{\"102\":1}}],[\"reset\",{\"1\":{\"102\":1}}],[\"res\",{\"1\":{\"5\":4}}],[\"里的区间查询则是用推导公式\",{\"1\":{\"21\":1}}],[\"分类\",{\"0\":{\"106\":1,\"108\":1,\"110\":1},\"2\":{\"107\":1,\"109\":1,\"111\":1}}],[\"分类为\",{\"1\":{\"90\":1}}],[\"分支\",{\"1\":{\"103\":2}}],[\"分支名称\",{\"1\":{\"103\":1}}],[\"分别都是不同系数的差分数组\",{\"1\":{\"21\":1}}],[\"分割等问题\",{\"1\":{\"11\":1}}],[\"而相反fetch会新增分支\",{\"1\":{\"103\":1}}],[\"而不是\",{\"1\":{\"37\":1}}],[\"而\",{\"1\":{\"21\":1,\"40\":1,\"103\":1}}],[\"迭代到\",{\"1\":{\"21\":1}}],[\"是一个自造的词\",{\"1\":{\"103\":1}}],[\"是\",{\"1\":{\"75\":1}}],[\"是上一轮的状态\",{\"1\":{\"30\":1}}],[\"是序列\",{\"1\":{\"24\":2}}],[\"是对指定区间进行维护的操作\",{\"1\":{\"21\":1}}],[\"是指状态转移方程中\",{\"1\":{\"11\":1}}],[\"解释\",{\"1\":{\"21\":1,\"30\":1}}],[\">=\",{\"1\":{\"28\":1,\"29\":1,\"30\":2,\"32\":1,\"36\":1,\"37\":2}}],[\">\",{\"1\":{\"19\":1,\"21\":1,\"72\":1,\"90\":12}}],[\">>\",{\"1\":{\"11\":2,\"36\":3,\"37\":3}}],[\">>=\",{\"1\":{\"5\":1}}],[\"x\",{\"1\":{\"19\":7,\"20\":7,\"21\":3,\"37\":5}}],[\"但注意\",{\"1\":{\"18\":1}}],[\"维护区间和\",{\"1\":{\"18\":1}}],[\"即先获取你的远端仓库数据再合并到你的本地仓库\",{\"1\":{\"103\":1}}],[\"即回文串\",{\"1\":{\"56\":1}}],[\"即选或者不选\",{\"1\":{\"51\":1}}],[\"即每个物品都有\",{\"1\":{\"35\":1}}],[\"即每个物品有无限次获取的机会\",{\"1\":{\"31\":1}}],[\"即未选择当前物品时的状态\",{\"1\":{\"30\":1}}],[\"即从\",{\"1\":{\"21\":1}}],[\"即\",{\"1\":{\"18\":1,\"43\":1}}],[\"即没有复杂的依赖关系\",{\"1\":{\"10\":1}}],[\"和\",{\"1\":{\"18\":1,\"21\":2,\"29\":1,\"40\":1,\"74\":1,\"90\":1}}],[\"和逆元数组\",{\"1\":{\"6\":1}}],[\"the\",{\"1\":{\"89\":1}}],[\"tex\",{\"0\":{\"82\":1}}],[\"toc\",{\"1\":{\"69\":1}}],[\"top\",{\"1\":{\"44\":1}}],[\"top++\",{\"1\":{\"44\":1}}],[\"t\",{\"1\":{\"28\":3,\"29\":4,\"30\":4}}],[\"title\",{\"1\":{\"89\":3}}],[\"ti\",{\"1\":{\"21\":3}}],[\"td\",{\"1\":{\"21\":6}}],[\"tmp\",{\"1\":{\"17\":5}}],[\"tree\",{\"0\":{\"8\":1,\"14\":1},\"2\":{\"13\":1,\"22\":1}}],[\"先删除从\",{\"1\":{\"59\":1}}],[\"先出现的元素离散化后的值更小\",{\"1\":{\"17\":1}}],[\"先求小区间的\",{\"1\":{\"11\":1}}],[\"vuepress\",{\"0\":{\"77\":1},\"1\":{\"73\":2,\"75\":2,\"76\":1,\"77\":2,\"78\":1,\"91\":1}}],[\"vuepress扩展\",{\"0\":{\"73\":1}}],[\"vue\",{\"0\":{\"67\":1},\"1\":{\"92\":2},\"2\":{\"68\":1}}],[\"vec\",{\"1\":{\"37\":4}}],[\"vector<int>\",{\"1\":{\"37\":1}}],[\"v\",{\"1\":{\"32\":2,\"34\":2,\"36\":3,\"37\":3}}],[\"val\",{\"1\":{\"17\":5}}],[\"void\",{\"1\":{\"5\":1,\"11\":1,\"20\":1,\"21\":1}}],[\"source\",{\"1\":{\"103\":1}}],[\"sort\",{\"1\":{\"17\":1}}],[\"shell\",{\"0\":{\"96\":1},\"2\":{\"97\":1}}],[\"sidebar\",{\"1\":{\"90\":1}}],[\"search\",{\"0\":{\"49\":1},\"2\":{\"53\":1}}],[\"substr\",{\"1\":{\"58\":1}}],[\"subsequence\",{\"0\":{\"39\":1},\"2\":{\"46\":1}}],[\"suffix\",{\"1\":{\"55\":2}}],[\"sum\",{\"1\":{\"21\":3}}],[\"s\",{\"1\":{\"35\":1,\"36\":2,\"37\":9,\"55\":4,\"56\":4,\"58\":2,\"59\":4,\"60\":2}}],[\"start\",{\"1\":{\"57\":2,\"58\":2}}],[\"string\",{\"0\":{\"54\":1},\"1\":{\"54\":1,\"61\":1},\"2\":{\"62\":1}}],[\"struct\",{\"1\":{\"17\":1}}],[\"stk+1+top\",{\"1\":{\"44\":1}}],[\"stk+1\",{\"1\":{\"44\":1}}],[\"stk\",{\"1\":{\"42\":1,\"43\":1,\"44\":2}}],[\"std\",{\"1\":{\"17\":2,\"61\":1}}],[\"special\",{\"0\":{\"14\":1},\"2\":{\"22\":1}}],[\"代码量小的数据结构\",{\"1\":{\"18\":1}}],[\"代码实现\",{\"0\":{\"17\":1}}],[\"代码解释\",{\"0\":{\"6\":1}}],[\"按出现顺序从小到大排序\",{\"1\":{\"16\":1}}],[\"将远程仓库中没有的提交记录都添加上去\",{\"1\":{\"103\":1}}],[\"将本地仓库上传到远程仓库\",{\"1\":{\"103\":1}}],[\"将某一个从a到b到分支的复制提交到当前指针下\",{\"1\":{\"102\":1}}],[\"将字符串从\",{\"1\":{\"59\":1}}],[\"将字符串\",{\"1\":{\"58\":1}}],[\"将每种物品的数量\",{\"1\":{\"37\":1}}],[\"将之前状态存储在左边\",{\"1\":{\"30\":1}}],[\"将离散化后的数字放回原数组\",{\"1\":{\"16\":1}}],[\"将副本按值从小到大排序\",{\"1\":{\"16\":1}}],[\"将时间复杂度从\",{\"1\":{\"6\":1}}],[\"离散化步骤\",{\"0\":{\"16\":1}}],[\"离散化和树状数组\",{\"0\":{\"14\":1},\"2\":{\"22\":1}}],[\"树状数组是一种支持\",{\"1\":{\"18\":1}}],[\"树状数组\",{\"0\":{\"18\":1}}],[\"树状数组离散化\",{\"1\":{\"14\":1}}],[\"树形\",{\"0\":{\"9\":1,\"12\":1},\"1\":{\"9\":1}}],[\"树形dp\",{\"0\":{\"8\":1},\"2\":{\"13\":1}}],[\"遍历顺序\",{\"1\":{\"12\":1}}],[\"状态转移\",{\"1\":{\"12\":1}}],[\"确定状态\",{\"1\":{\"12\":1}}],[\"并返回第一个找到的字符\",{\"1\":{\"57\":1}}],[\"并不一定就是最终答案\",{\"1\":{\"40\":1}}],[\"并设定一个归属\",{\"1\":{\"12\":1}}],[\"并对结果取模\",{\"1\":{\"4\":1}}],[\"构造一种方案\",{\"1\":{\"12\":1}}],[\"从\",{\"1\":{\"58\":1}}],[\"从字符串的\",{\"1\":{\"58\":1}}],[\"从末尾开始查找\",{\"1\":{\"57\":1}}],[\"从而高效地构建潜在的最长上升子序列\",{\"1\":{\"42\":1}}],[\"从而确保每个物品只被选择一次\",{\"1\":{\"30\":1}}],[\"从而完成状态的转移\",{\"1\":{\"12\":1}}],[\"从右往左遍历可以保证\",{\"1\":{\"30\":1}}],[\"从左往右遍历时\",{\"1\":{\"34\":1}}],[\"从左往右遍历\",{\"1\":{\"30\":1}}],[\"从子树的解推导出父节点的解\",{\"1\":{\"12\":1}}],[\"destination\",{\"1\":{\"103\":1}}],[\"destination这里有一点是需要注意的\",{\"1\":{\"103\":1}}],[\"destination这个参数实际的值是个\",{\"1\":{\"103\":1}}],[\"describe\",{\"1\":{\"102\":1}}],[\"d\",{\"1\":{\"21\":2,\"103\":1}}],[\"data\",{\"1\":{\"17\":3}}],[\"discretization\",{\"0\":{\"14\":1},\"2\":{\"22\":1}}],[\"dfs基于栈\",{\"1\":{\"51\":1}}],[\"dfsbfs\",{\"1\":{\"50\":1}}],[\"dfs\",{\"0\":{\"51\":1},\"1\":{\"12\":1}}],[\"dp区间\",{\"1\":{\"9\":1}}],[\"dp\",{\"0\":{\"4\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1,\"26\":1},\"1\":{\"9\":1,\"10\":5,\"11\":8,\"12\":1,\"28\":6,\"29\":7,\"30\":7,\"32\":6,\"33\":1,\"34\":7,\"36\":3,\"37\":3,\"40\":6},\"2\":{\"13\":1,\"38\":1}}],[\"中找到\",{\"1\":{\"103\":1}}],[\"中找出第一个大于等于\",{\"1\":{\"43\":1}}],[\"中使用\",{\"1\":{\"92\":1}}],[\"中设置页面信息\",{\"1\":{\"90\":1}}],[\"中设置页面标题\",{\"1\":{\"89\":1}}],[\"中的第一个\",{\"1\":{\"89\":1}}],[\"中的\",{\"1\":{\"77\":1}}],[\"中很重要的一个概念\",{\"1\":{\"75\":1}}],[\"中自定义它们\",{\"1\":{\"69\":1}}],[\"中第\",{\"1\":{\"24\":2}}],[\"中\",{\"1\":{\"12\":1}}],[\"核心思想是将原问题分解为若干子问题\",{\"1\":{\"12\":1}}],[\"3\",{\"0\":{\"12\":1,\"35\":1,\"44\":1},\"1\":{\"18\":1}}],[\"301\",{\"1\":{\"11\":1}}],[\"转移到大区间\",{\"1\":{\"11\":1}}],[\"步骤\",{\"1\":{\"11\":1,\"12\":1}}],[\"合并\",{\"1\":{\"11\":1}}],[\"盆\",{\"1\":{\"10\":1}}],[\"盆花\",{\"1\":{\"10\":1}}],[\"第三形态\",{\"0\":{\"30\":1,\"34\":1}}],[\"第二形态\",{\"0\":{\"29\":1,\"33\":1,\"37\":1}}],[\"第一形态\",{\"0\":{\"28\":1,\"32\":1,\"36\":1}}],[\"第\",{\"1\":{\"10\":1}}],[\"knapsack\",{\"0\":{\"26\":1},\"2\":{\"38\":1}}],[\"k\",{\"1\":{\"10\":5,\"11\":4,\"20\":2,\"21\":9,\"37\":4}}],[\"种花放了\",{\"1\":{\"10\":1}}],[\"种花为止\",{\"1\":{\"10\":1}}],[\"种为止\",{\"1\":{\"10\":1}}],[\"初始化\",{\"1\":{\"10\":1,\"11\":1}}],[\"初始化边界条件\",{\"1\":{\"4\":1}}],[\"pick\",{\"1\":{\"102\":2}}],[\"place在某个节点创建分支并转移到该节点\",{\"1\":{\"102\":1}}],[\"place\",{\"1\":{\"102\":1}}],[\"pull也就当成是fetch\",{\"1\":{\"103\":1}}],[\"pull\",{\"1\":{\"103\":1}}],[\"public\",{\"1\":{\"91\":1}}],[\"push\",{\"1\":{\"37\":2,\"103\":4}}],[\"pageinfo\",{\"1\":{\"90\":1}}],[\"page\",{\"0\":{\"88\":1},\"1\":{\"89\":1},\"2\":{\"93\":1}}],[\"pair\",{\"1\":{\"17\":1}}],[\"pos\",{\"1\":{\"44\":1,\"59\":5,\"60\":4}}],[\"pos==top+1\",{\"1\":{\"44\":1}}],[\"pos=lower\",{\"1\":{\"44\":1}}],[\"p1122\",{\"1\":{\"12\":1}}],[\"p1077\",{\"1\":{\"10\":1}}],[\"p5569\",{\"1\":{\"11\":1}}],[\"prev\",{\"1\":{\"90\":1}}],[\"prefix\",{\"1\":{\"56\":2}}],[\"pre\",{\"1\":{\"5\":1,\"6\":1,\"11\":5}}],[\"例题\",{\"1\":{\"10\":1,\"11\":1,\"12\":1}}],[\"总数为\",{\"1\":{\"10\":1}}],[\"通过\",{\"1\":{\"75\":1,\"78\":1}}],[\"通过巧妙维护单调栈\",{\"1\":{\"44\":1}}],[\"通过这种方式\",{\"1\":{\"37\":1,\"43\":1}}],[\"通过求解子问题来得到原问题的解\",{\"1\":{\"12\":1}}],[\"通过二进制拆分的方式\",{\"1\":{\"6\":1}}],[\"通常利用树的递归性质\",{\"1\":{\"12\":1}}],[\"通常用于解决区间划分\",{\"1\":{\"11\":1}}],[\"通常用于解决序列或数组上的问题\",{\"1\":{\"10\":1}}],[\"区间修改\",{\"0\":{\"21\":1},\"1\":{\"18\":1}}],[\"区间查询\",{\"0\":{\"19\":1},\"1\":{\"18\":1}}],[\"区间\",{\"0\":{\"8\":1,\"9\":1,\"11\":1},\"1\":{\"11\":1},\"2\":{\"13\":1}}],[\"线性\",{\"0\":{\"8\":1,\"9\":1,\"10\":1},\"2\":{\"13\":1}}],[\"lastupdated\",{\"1\":{\"90\":1}}],[\"layout\",{\"0\":{\"69\":1},\"2\":{\"70\":1}}],[\"l\",{\"1\":{\"56\":1}}],[\"linux\",{\"0\":{\"94\":1},\"2\":{\"95\":1}}],[\"linear\",{\"0\":{\"8\":1},\"2\":{\"13\":1}}],[\"lis\",{\"1\":{\"39\":1}}],[\"ll\",{\"1\":{\"21\":3}}],[\"lolol\",{\"1\":{\"72\":1}}],[\"longest\",{\"0\":{\"39\":1},\"2\":{\"46\":1}}],[\"lowbit\",{\"1\":{\"19\":1,\"20\":1,\"21\":2}}],[\"logy\",{\"1\":{\"82\":2}}],[\"log\",{\"1\":{\"37\":1}}],[\"logn\",{\"1\":{\"18\":2}}],[\"logb\",{\"1\":{\"6\":1}}],[\"len\",{\"1\":{\"11\":3,\"58\":3}}],[\"数组\",{\"1\":{\"56\":1}}],[\"数组离散化\",{\"0\":{\"15\":1}}],[\"数组存储逆元\",{\"1\":{\"6\":1}}],[\"数组存储阶乘\",{\"1\":{\"6\":1}}],[\"数据规模较小时使用动态规划\",{\"0\":{\"4\":1}}],[\"其时间复杂度为\",{\"1\":{\"61\":1}}],[\"其中\",{\"1\":{\"6\":1,\"24\":1}}],[\"其核心思路基于组合数的递推公式\",{\"1\":{\"4\":1}}],[\"方便后续计算组合数时直接使用\",{\"1\":{\"6\":1}}],[\"方法有两种常见用法\",{\"1\":{\"59\":1}}],[\"方法二\",{\"0\":{\"5\":1}}],[\"方法一\",{\"0\":{\"4\":1}}],[\"预处理阶乘数组\",{\"1\":{\"6\":1}}],[\"预处理阶乘和逆元\",{\"1\":{\"5\":1}}],[\"originsource\",{\"1\":{\"103\":2}}],[\"origin\",{\"1\":{\"103\":2}}],[\"other\",{\"0\":{\"98\":1},\"2\":{\"99\":1}}],[\"operator<\",{\"1\":{\"17\":1}}],[\"o\",{\"1\":{\"6\":2,\"17\":4,\"18\":3,\"103\":2}}],[\"函数\",{\"1\":{\"6\":3}}],[\"根据预处理好的阶乘和逆元\",{\"1\":{\"6\":1}}],[\"根据组合数公式计算结果\",{\"1\":{\"5\":1}}],[\"根据递推公式计算组合数\",{\"1\":{\"4\":1}}],[\"||\",{\"1\":{\"5\":2}}],[\"2020\",{\"1\":{\"90\":1}}],[\"213这样在已知个数的情况下枚举排列顺序\",{\"1\":{\"51\":1}}],[\"231\",{\"1\":{\"51\":1}}],[\"2\",{\"0\":{\"11\":1,\"31\":1,\"43\":1,\"52\":1},\"1\":{\"5\":1,\"11\":1,\"18\":1,\"24\":2,\"37\":2,\"83\":1}}],[\"fetch\",{\"1\":{\"103\":2}}],[\"fenwick\",{\"0\":{\"14\":1},\"2\":{\"22\":1}}],[\"f强制移动\",{\"1\":{\"102\":1}}],[\"f\",{\"1\":{\"102\":2}}],[\"found\",{\"1\":{\"105\":1}}],[\"foo\",{\"1\":{\"103\":1}}],[\"footer\",{\"1\":{\"90\":1}}],[\"for\",{\"1\":{\"4\":3,\"5\":1,\"10\":3,\"11\":5,\"17\":2,\"21\":2,\"28\":2,\"29\":2,\"30\":2,\"32\":2,\"34\":2,\"36\":2,\"37\":3,\"40\":3,\"44\":1}}],[\"false\",{\"1\":{\"90\":12}}],[\"fac\",{\"1\":{\"5\":5,\"6\":2}}],[\"first\",{\"1\":{\"89\":1}}],[\"find\",{\"1\":{\"57\":1}}],[\"frontmatter\",{\"1\":{\"69\":1,\"75\":4,\"89\":1,\"90\":2}}],[\"front\",{\"0\":{\"65\":1},\"2\":{\"66\":1}}],[\"will\",{\"1\":{\"89\":1}}],[\"wiki\",{\"1\":{\"3\":1,\"9\":1,\"14\":1,\"23\":1,\"26\":1,\"39\":1,\"50\":1,\"54\":1}}],[\"www\",{\"1\":{\"72\":1}}],[\"w\",{\"1\":{\"30\":4,\"32\":1,\"34\":4,\"36\":2,\"37\":2}}],[\"work\",{\"1\":{\"11\":1}}],[\"while\",{\"1\":{\"5\":1,\"19\":1,\"20\":1,\"36\":1,\"37\":1}}],[\"qp\",{\"1\":{\"5\":2,\"6\":1}}],[\"b强制把a移动到b\",{\"1\":{\"102\":1}}],[\"branch\",{\"1\":{\"102\":3,\"103\":1}}],[\"breadcrumb\",{\"1\":{\"90\":1}}],[\"be\",{\"1\":{\"89\":1}}],[\"baidu\",{\"1\":{\"72\":1}}],[\"backtotop\",{\"1\":{\"90\":1}}],[\"back\",{\"0\":{\"63\":1},\"1\":{\"37\":2},\"2\":{\"64\":1}}],[\"bfs基于队列\",{\"1\":{\"52\":1}}],[\"bfs\",{\"0\":{\"52\":1},\"1\":{\"52\":2}}],[\"bound即可\",{\"1\":{\"44\":1}}],[\"bound\",{\"1\":{\"44\":1}}],[\"bool\",{\"1\":{\"17\":1}}],[\"bn​\",{\"1\":{\"24\":1}}],[\"b3​\",{\"1\":{\"24\":1}}],[\"b2​\",{\"1\":{\"24\":1}}],[\"b1​\",{\"1\":{\"24\":1}}],[\"b\",{\"1\":{\"5\":5,\"6\":1,\"24\":3,\"102\":4,\"103\":1}}],[\"的字符串\",{\"1\":{\"58\":1}}],[\"的以\",{\"1\":{\"56\":1}}],[\"的从\",{\"1\":{\"55\":1}}],[\"的位置取代\",{\"1\":{\"44\":1}}],[\"的位置\",{\"1\":{\"43\":1,\"44\":1,\"57\":2}}],[\"的幂次方的组合\",{\"1\":{\"37\":1}}],[\"的规则\",{\"1\":{\"30\":1,\"34\":1}}],[\"的最大价值\",{\"1\":{\"28\":1,\"29\":1,\"32\":1,\"33\":1,\"34\":1}}],[\"的最大值\",{\"1\":{\"24\":1}}],[\"的区间和\",{\"1\":{\"21\":1}}],[\"的不同管辖区间修改操作\",{\"1\":{\"21\":1}}],[\"的和\",{\"1\":{\"19\":1}}],[\"的总方案数\",{\"1\":{\"10\":1}}],[\"的阶乘的逆元都为\",{\"1\":{\"5\":1}}],[\"的阶乘和\",{\"1\":{\"5\":1}}],[\"的\",{\"1\":{\"5\":1,\"18\":1,\"89\":1,\"90\":1}}],[\"的范围\",{\"1\":{\"4\":1}}],[\"as\",{\"1\":{\"89\":1}}],[\"append\",{\"1\":{\"58\":1}}],[\"acm\",{\"0\":{\"47\":1},\"2\":{\"48\":1}}],[\"an​\",{\"1\":{\"24\":1}}],[\"ans=max\",{\"1\":{\"40\":1,\"44\":1}}],[\"ans=0\",{\"1\":{\"40\":1}}],[\"ans\",{\"1\":{\"19\":4,\"40\":1,\"44\":1}}],[\"a3​\",{\"1\":{\"24\":1}}],[\"a2​\",{\"1\":{\"24\":1}}],[\"a1​\",{\"1\":{\"24\":1}}],[\"add\",{\"1\":{\"20\":1,\"21\":1}}],[\"arr\",{\"1\":{\"17\":2}}],[\"a\",{\"1\":{\"5\":6,\"10\":1,\"11\":3,\"19\":2,\"24\":3,\"40\":1,\"43\":5,\"44\":1,\"102\":3}}],[\"快速幂函数\",{\"1\":{\"5\":1}}],[\"​+⋯+a\",{\"1\":{\"24\":1}}],[\"​+a\",{\"1\":{\"24\":1}}],[\"​b\",{\"1\":{\"24\":3}}],[\"​\",{\"1\":{\"5\":1,\"24\":3}}],[\"当source为空时push会删除destination的分支\",{\"1\":{\"103\":1}}],[\"当然\",{\"1\":{\"101\":1}}],[\"当找到合适位置时\",{\"1\":{\"44\":1}}],[\"当遇到能使上升子序列更长的元素时\",{\"1\":{\"44\":1}}],[\"当前的状态存储在数组末尾\",{\"1\":{\"30\":1}}],[\"当前状态下空间为\",{\"1\":{\"29\":1,\"33\":1}}],[\"当下标\",{\"1\":{\"18\":1}}],[\"当值相同时\",{\"1\":{\"16\":1,\"17\":1}}],[\"当空间足够时\",{\"1\":{\"5\":1}}],[\"当数据规模较小时\",{\"1\":{\"4\":1}}],[\"+rebase\",{\"1\":{\"103\":1}}],[\"+1\",{\"1\":{\"40\":1}}],[\"+=\",{\"1\":{\"21\":4}}],[\"+\",{\"1\":{\"4\":1,\"10\":1,\"11\":5,\"17\":3,\"19\":1,\"20\":2,\"21\":1,\"28\":1,\"29\":1,\"30\":1,\"32\":1,\"34\":1,\"36\":1,\"37\":1,\"92\":1,\"103\":1}}],[\"++len\",{\"1\":{\"11\":1}}],[\"++k\",{\"1\":{\"10\":1,\"11\":1}}],[\"++j\",{\"1\":{\"4\":1,\"10\":1,\"11\":1,\"28\":1,\"29\":1,\"32\":1,\"34\":1,\"40\":1}}],[\"++i\",{\"1\":{\"4\":2,\"5\":1,\"10\":1,\"11\":3,\"17\":2,\"28\":1,\"29\":1,\"30\":1,\"32\":1,\"34\":1,\"36\":1,\"37\":1,\"40\":2,\"44\":1}}],[\"merge\",{\"1\":{\"102\":1,\"103\":1}}],[\"ms\",{\"1\":{\"90\":1}}],[\"main你把一个从未见过的name分支作为远程跟踪o\",{\"1\":{\"103\":1}}],[\"main处\",{\"1\":{\"103\":1}}],[\"main会移动到远程仓库的main处\",{\"1\":{\"103\":1}}],[\"main\",{\"1\":{\"103\":6}}],[\"markdown\",{\"0\":{\"71\":1,\"74\":1,\"75\":1,\"76\":1},\"1\":{\"73\":2,\"74\":3,\"75\":1,\"76\":3,\"77\":2,\"78\":1,\"89\":3,\"90\":1,\"91\":2,\"92\":2},\"2\":{\"87\":1}}],[\"max\",{\"1\":{\"28\":1,\"29\":1,\"30\":1,\"32\":1,\"34\":1,\"36\":1,\"37\":1}}],[\"max=a\",{\"1\":{\"24\":1}}],[\"maxn\",{\"1\":{\"17\":1}}],[\"min\",{\"1\":{\"11\":1}}],[\"mx\",{\"1\":{\"5\":1,\"11\":5,\"40\":1}}],[\"mod\",{\"1\":{\"4\":1,\"5\":9,\"10\":1}}],[\"m\",{\"1\":{\"4\":1,\"5\":6,\"6\":1,\"10\":1,\"28\":2,\"29\":3,\"30\":1,\"32\":1,\"34\":1,\"36\":1,\"37\":1}}],[\"<<=\",{\"1\":{\"37\":1}}],[\"<<\",{\"1\":{\"29\":2}}],[\"<\",{\"1\":{\"4\":1,\"5\":2,\"11\":1,\"17\":2,\"72\":1,\"90\":12}}],[\"<=a\",{\"1\":{\"40\":1}}],[\"<=\",{\"1\":{\"4\":3,\"10\":4,\"11\":4,\"17\":2,\"20\":1,\"21\":1,\"28\":2,\"29\":2,\"30\":1,\"32\":2,\"34\":2,\"36\":1,\"37\":1}}],[\"避免越界\",{\"1\":{\"4\":1}}],[\"j<i\",{\"1\":{\"40\":1}}],[\"j=1\",{\"1\":{\"40\":1}}],[\"j\",{\"1\":{\"4\":7,\"10\":9,\"11\":9,\"24\":1,\"28\":10,\"29\":10,\"30\":13,\"32\":10,\"33\":2,\"34\":12,\"36\":6,\"37\":6,\"40\":4}}],[\"注意\",{\"1\":{\"4\":1,\"44\":1}}],[\"not\",{\"1\":{\"105\":1}}],[\"name同上\",{\"1\":{\"103\":1}}],[\"name将某一个分支的复制提交在当前指针下\",{\"1\":{\"102\":1}}],[\"name撤销到某一个分支并产生一个新的分支\",{\"1\":{\"102\":1}}],[\"name撤销到某一个分支\",{\"1\":{\"102\":1}}],[\"name切换到某一个分支\",{\"1\":{\"102\":1}}],[\"name\",{\"1\":{\"102\":8,\"103\":2}}],[\"navbar\",{\"1\":{\"90\":1}}],[\"next\",{\"1\":{\"90\":1}}],[\"n−m\",{\"1\":{\"5\":1}}],[\"n\",{\"1\":{\"4\":2,\"5\":7,\"6\":1,\"10\":1,\"11\":6,\"17\":3,\"20\":1,\"21\":2,\"24\":2,\"29\":1,\"32\":1,\"34\":1,\"36\":1,\"37\":1,\"59\":4,\"60\":2,\"61\":1}}],[\"numbers\",{\"0\":{\"2\":1},\"2\":{\"7\":1}}],[\"=s\",{\"1\":{\"55\":1,\"56\":2}}],[\"=a\",{\"1\":{\"44\":1}}],[\"=max\",{\"1\":{\"40\":1}}],[\"=1\",{\"1\":{\"40\":1}}],[\"==\",{\"1\":{\"5\":2,\"17\":1}}],[\"=\",{\"1\":{\"4\":5,\"5\":8,\"10\":5,\"11\":11,\"17\":4,\"19\":3,\"20\":2,\"21\":4,\"28\":4,\"29\":5,\"30\":4,\"32\":4,\"34\":3,\"36\":3,\"37\":5,\"57\":1,\"82\":1}}],[\"19th\",{\"1\":{\"85\":1}}],[\"132\",{\"1\":{\"51\":1}}],[\"123\",{\"1\":{\"51\":1}}],[\"1\",{\"0\":{\"10\":1,\"27\":1,\"42\":1,\"51\":1},\"1\":{\"4\":7,\"5\":7,\"10\":3,\"11\":7,\"17\":4,\"18\":2,\"19\":1,\"21\":2,\"24\":2,\"28\":5,\"29\":5,\"30\":1,\"32\":3,\"34\":1,\"36\":1,\"37\":4,\"57\":2,\"83\":1,\"90\":2,\"92\":2}}],[\"01\",{\"0\":{\"27\":1},\"1\":{\"29\":1,\"30\":1,\"37\":1}}],[\"0\",{\"1\":{\"4\":3,\"5\":7,\"10\":4,\"18\":1,\"19\":2,\"21\":2,\"29\":1,\"32\":1,\"56\":2,\"57\":3,\"58\":1}}],[\"ir⋯\",{\"1\":{\"82\":1}}],[\"it\",{\"1\":{\"76\":2}}],[\"i<=n\",{\"1\":{\"40\":2,\"44\":1}}],[\"i=1\",{\"1\":{\"40\":2,\"44\":1}}],[\"i=1∑r​di​×\",{\"1\":{\"21\":1}}],[\"idx\",{\"1\":{\"17\":4}}],[\"in\",{\"1\":{\"89\":1}}],[\"insert\",{\"1\":{\"60\":1}}],[\"increasing\",{\"0\":{\"39\":1},\"2\":{\"46\":1}}],[\"inf\",{\"1\":{\"11\":2}}],[\"inv\",{\"1\":{\"5\":4,\"6\":2}}],[\"interval\",{\"0\":{\"8\":1},\"2\":{\"13\":1}}],[\"int\",{\"1\":{\"4\":3,\"5\":9,\"10\":3,\"11\":7,\"17\":3,\"19\":3,\"20\":2,\"21\":4,\"28\":2,\"29\":3,\"30\":2,\"32\":2,\"34\":2,\"36\":2,\"37\":4,\"40\":4,\"44\":2}}],[\"if\",{\"1\":{\"5\":2,\"17\":1,\"28\":1,\"29\":1,\"30\":1,\"32\":1,\"37\":1,\"40\":1,\"44\":1}}],[\"i\",{\"1\":{\"4\":10,\"5\":7,\"10\":10,\"11\":17,\"17\":9,\"21\":15,\"24\":5,\"28\":12,\"29\":6,\"30\":9,\"32\":12,\"34\":8,\"35\":1,\"36\":2,\"37\":2,\"40\":7,\"43\":5,\"44\":4,\"55\":5,\"56\":5,\"92\":1,\"102\":1}}],[\"clone\",{\"1\":{\"103\":1}}],[\"c1^\",{\"1\":{\"102\":1}}],[\"cherry\",{\"1\":{\"102\":2}}],[\"checkout\",{\"1\":{\"102\":3,\"103\":1}}],[\"ch\",{\"1\":{\"57\":4}}],[\"char\",{\"1\":{\"56\":1}}],[\"cin\",{\"1\":{\"11\":2,\"36\":1,\"37\":1}}],[\"cij​=ci−1j​+ci−1j−1​\",{\"1\":{\"4\":1}}],[\"contributors\",{\"1\":{\"90\":1}}],[\"const\",{\"1\":{\"11\":1,\"17\":2}}],[\"commit\",{\"1\":{\"102\":1}}],[\"comment\",{\"1\":{\"90\":1}}],[\"com\",{\"1\":{\"72\":1}}],[\"combination\",{\"0\":{\"2\":1},\"2\":{\"7\":1}}],[\"cout\",{\"1\":{\"29\":1}}],[\"cnm​=m\",{\"1\":{\"5\":1}}],[\"c\",{\"1\":{\"4\":5,\"5\":2,\"6\":2,\"19\":1,\"20\":2,\"102\":1}}]],\"version\":2}}")).map(([e,t])=>[e,It(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=Ct[s];e==="suggest"?self.postMessage([e,o,et(t,r,n)]):e==="search"?self.postMessage([e,o,tt(t,r,n)]):self.postMessage({suggestions:[e,o,et(t,r,n)],results:[e,o,tt(t,r,n)]})};
//# sourceMappingURL=index.js.map
